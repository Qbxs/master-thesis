@article{10.1145/3409006,
  author     = {Parreaux, Lionel},
  title      = {The Simple Essence of Algebraic Subtyping: Principal Type Inference with Subtyping Made Easy (Functional Pearl)},
  year       = {2020},
  issue_date = {August 2020},
  publisher  = {Association for Computing Machinery},
  address    = {New York, NY, USA},
  volume     = {4},
  number     = {ICFP},
  url        = {https://doi.org/10.1145/3409006},
  doi        = {10.1145/3409006},
  abstract   = {MLsub extends traditional Hindley-Milner type inference with subtyping while preserving compact principal types, an exciting new development. However, its specification in terms of biunification is difficult to understand, relying on the new concepts of bisubstitution and polar types, and making use of advanced notions from abstract algebra. In this paper, we show that these are in fact not essential to understanding the mechanisms at play in MLsub. We propose an alternative algorithm called Simple-sub, which can be implemented efficiently in under 500 lines of code (including parsing, simplification, and pretty-printing), looks more familiar, and is easier to understand. We present an experimental evaluation of Simple-sub against MLsub on a million randomly-generated well-scoped expressions, showing that the two systems agree. The mutable automaton-based implementation of MLsub is quite far from its algebraic specification, leaving a lot of space for errors; in fact, our evaluation uncovered several bugs in it. We sketch more straightforward soundness and completeness arguments for Simple-sub, based on a syntactic specification of the type system. This paper is meant to be light in formalism, rich in insights, and easy to consume for prospective designers of new type systems and programming languages. In particular, no abstract algebra is inflicted on readers.},
  journal    = {Proc. ACM Program. Lang.},
  month      = {aug},
  articleno  = {124},
  numpages   = {28},
  keywords   = {type inference, subtyping, principal types}
}

@inproceedings{binder22refinement,
  author    = {Binder, David and Skupin, Ingo and Läwen, David and Ostermann, Klaus},
  title     = {Structural Refinement Types},
  booktitle = {Proceedings of the International Workshop on Type-Driven Development},
  year      = {2022},
  publisher = {ACM Press},
  doi       = {10.1145/3240719.3241788}
}

@inproceedings{castagna,
  author  = {Castagna, Giuseppe and Xu, Zhiwu},
  year    = {2011},
  month   = {09},
  pages   = {94-106},
  title   = {Set-theoretic Foundation of Parametric Polymorphism and Subtyping},
  volume  = {46},
  journal = {Sigplan Notices - SIGPLAN},
  doi     = {10.1145/2034574.2034788}
}
@article{curien2000duality,
  title     = {The duality of computation},
  author    = {Curien, Pierre-Louis and Herbelin, Hugo},
  journal   = {ACM sigplan notices},
  volume    = {35},
  number    = {9},
  pages     = {233--243},
  year      = {2000},
  publisher = {ACM New York, NY, USA}
}

@book{dolan2017subtyping,
  author    = {Dolan, Stephen},
  title     = {Algebraic Subtyping: Distinguished Dissertation 2017},
  year      = {2017},
  isbn      = {1780174152},
  publisher = {BCS},
  address   = {Swindon, GBR},
  abstract  = {Type inference gives programmers the benefit of static, compile-time type checking without the cost of manually specifying types, and has long been a standard feature of functional programming languages. However, it has proven difficult to integrate type inference with subtyping, since the unification engine at the core of classical type inference accepts only equations, not subtyping constraints. This thesis presents a type system combining ML-style parametric polymorphism and subtyping, with type inference, principal types, and decidable type subsumption. Type inference is based on biunification, an analogue of unification that works with subtyping constraints. Making this possible are several contributions, beginning with the notion of an extensible type system, in which an open world of types is assumed, so that no typeable program becomes untypeable by the addition of new types to the language. While previous formulations of subtyping fail to be extensible, this thesis shows that adopting a more algebraic approach can remedy this. Using such an approach, this thesis develops the theory of biunification, shows how it is used to infer types, and shows how it can be efficiently implemented, exploiting deep connections between the algebra of regular languages and polymorphic subtyping.}
}

      

@inproceedings{dolanMLsub,
  author    = {Dolan, Stephen and Mycroft, Alan},
  title     = {Polymorphism, Subtyping, and Type Inference in MLsub},
  year      = {2017},
  isbn      = {9781450346603},
  publisher = {Association for Computing Machinery},
  address   = {New York, NY, USA},
  url       = {https://doi.org/10.1145/3009837.3009882},
  doi       = {10.1145/3009837.3009882},
  abstract  = {We present a type system combining subtyping and ML-style parametric polymorphism. Unlike previous work, our system supports type inference and has compact principal types. We demonstrate this system in the minimal language MLsub, which types a strict superset of core ML programs. This is made possible by keeping a strict separation between the types used to describe inputs and those used to describe outputs, and extending the classical unification algorithm to handle subtyping constraints between these input and output types. Principal types are kept compact by type simplification, which exploits deep connections between subtyping and the algebra of regular languages. An implementation is available online.},
  booktitle = {Proceedings of the 44th ACM SIGPLAN Symposium on Principles of Programming Languages},
  pages     = {60–72},
  numpages  = {13},
  keywords  = {Type Inference, Algebra, Polymorphism, Subtyping},
  location  = {Paris, France},
  series    = {POPL '17}
}


@article{downen2017phd,
  title     = {Sequent Calculus: A Logic and a Language for Computation and Duality},
  author    = {Downen, Paul},
  year      = {2017},
  publisher = {University of Oregon}
}

@article{downen2018tutorial,
  title     = {A tutorial on computational classical logic and the sequent calculus},
  author    = {Downen, Paul and Ariola, Zena M},
  journal   = {Journal of Functional Programming},
  volume    = {28},
  year      = {2018},
  publisher = {Cambridge University Press}
}

@inproceedings{duality,
  author    = {Downen, Paul and Ariola, Zena M.},
  title     = {{Duality in Action}},
  booktitle = {6th International Conference on Formal Structures for Computation and Deduction (FSCD 2021)},
  pages     = {1:1--1:32},
  series    = {Leibniz International Proceedings in Informatics (LIPIcs)},
  isbn      = {978-3-95977-191-7},
  issn      = {1868-8969},
  year      = {2021},
  volume    = {195},
  editor    = {Kobayashi, Naoki},
  publisher = {Schloss Dagstuhl -- Leibniz-Zentrum f{\"u}r Informatik},
  address   = {Dagstuhl, Germany},
  url       = {https://drops.dagstuhl.de/opus/volltexte/2021/14239},
  urn       = {urn:nbn:de:0030-drops-142390},
  doi       = {10.4230/LIPIcs.FSCD.2021.1},
  annote    = {Keywords: Duality, Logic, Curry-Howard, Sequent Calculus, Rewriting, Compilation}
}

@misc{duo,
  title        = {Duo Language Documentation},
  howpublished = {https://duo-lang.github.io/documentation},
  note         = {Accessed: 30.01.2023}
}

@inproceedings{Girard1972InterpretationFE,
  title  = {Interpretation fonctionelle et elimination des coupures dans l'aritmetique d'ordre superieur},
  author = {J. Y. Girard},
  year   = {1972}
}

@book{Haskell98,
  description  = {This report defines the syntax for Haskell programs and an informal abstract semantics for the meaning of such programs.},
  editor       = {Jones, Simon Peyton},
  howpublished = {PDF},
  keywords     = {haskell msc},
  month        = {September},
  pages        = 277,
  publisher    = {http://haskell.org/},
  timestamp    = {2007-07-26T01:25:05.000+0200},
  title        = {Haskell 98 Language and Libraries: The Revised Report},
  type         = {Language Definition},
  url          = {http://haskell.org/definition/haskell98-report.pdf},
  year         = 2002
}


@book{jones2003qualified,
  title     = {Qualified Types: Theory and Practice},
  author    = {Jones, M.P.},
  isbn      = {9780521543262},
  lccn      = {lc94028540},
  series    = {Distinguished Dissertations in Computer Science},
  url       = {https://books.google.de/books?id=43JKbm523AwC},
  year      = {2003},
  publisher = {Cambridge University Press}
}

@phdthesis{Kilpatrick2019-cy,
  title     = {Non-reformist reform for Haskell Modularity},
  author    = {Kilpatrick, Scott},
  publisher = {Universit{\"a}t des Saarlandes},
  school    = {Universit{\"a}t des Saarlandes},
  year      = 2019
}

@online{kiselyov,
  author  = {Oleg Kiselyov},
  title   = {Implementing, and Understanding Type Classes},
  year    = {2021},
  url     = {https://okmij.org/ftp/Computation/typeclass.html},
  urldate = {2022-08-17}
}

@inproceedings{leijen2005extensible,
  author    = {Leijen, Daan},
  title     = {Extensible records with scoped labels},
  booktitle = {Proceedings of the 2005 Symposium on Trends in Functional Programming (TFP'05), Tallin, Estonia},
  year      = {2005},
  month     = {September},
  abstract  = {Records provide a safe and flexible way to construct data structures. We describe a natural approach to typing polymorphic and extensible records that is simple, easy to use in practice, and straightforward to implement. A novel aspect of this work is that records can contain duplicate labels, effectively introducing a form of scoping over the labels. Furthermore, it is a fully orthogonal extension to existing type systems and programming languages. In particular, we show how it can be used conveniently with standard Hindley-Milner, qualified types, and ML-F. The records are implemented in the experimental Morrow interpreter. There is separate technical report that gives the constructive proofs of soundness and completeness.},
  url       = {https://www.microsoft.com/en-us/research/publication/extensible-records-with-scoped-labels/},
  edition   = {Proceedings of the 2005 Symposium on Trends in Functional Programming (TFP'05), Tallin, Estonia}
}

@article{liskov,
  author     = {Liskov, Barbara},
  title      = {Keynote Address - Data Abstraction and Hierarchy},
  year       = {1987},
  issue_date = {May 1988},
  publisher  = {Association for Computing Machinery},
  address    = {New York, NY, USA},
  volume     = {23},
  number     = {5},
  issn       = {0362-1340},
  url        = {https://doi.org/10.1145/62139.62141},
  doi        = {10.1145/62139.62141},
  journal    = {SIGPLAN Not.},
  month      = {jan},
  pages      = {17–34},
  numpages   = {18}
}

@inproceedings{morris2010instance,
  title     = {Instance chains: type class programming without overlapping instances},
  author    = {Morris, J Garrett and Jones, Mark P},
  booktitle = {Proceedings of the 15th ACM SIGPLAN international conference on Functional programming},
  pages     = {375--386},
  year      = {2010}
}

@inproceedings{peytonjones1997type,
  author    = {Peyton Jones, Simon and Jones, Mark and Meijer, Erik},
  title     = {Type classes: an exploration of the design space},
  booktitle = {Haskell workshop},
  year      = {1997},
  month     = {January},
  abstract  = {When type classes were first introduced in Haskell they were regarded as a fairly experimental language feature, and therefore warranted a fairly conservative design. Since that time, practical experience has convinced many programmers of the benefits and convenience of type classes. However, on occasion, these same programmers have discovered examples where seemingly natural applications for type class overloading are prevented by the restrictions imposed by the Haskell design.
               
               It is possible to extend the type class mechanism of Haskell in various ways to overcome these limitations, but such proposals must be designed with great care. For example, several different extensions have been implemented in Gofer. Some of these, particularly the support for multi-parameter classes, have proved to be very useful, but interactions between other aspects of the design have resulted in a type system that is both unsound and undecidable. Another illustration is the introduction of constructor classes in Haskell 1.3, which came without the proper generalization of the notion of a context. As a consequence, certain quite reasonable programs are not typable.
               
               In this paper we review the rationale behind the design of Haskell's class system, we identify some of the weaknesses in the current situation, and we explain the choices that we face in attempting to remove them.},
  url       = {https://www.microsoft.com/en-us/research/publication/type-classes-an-exploration-of-the-design-space/},
  edition   = {Haskell workshop}
}

@book{reynolds_1998,
  place     = {Cambridge},
  title     = {Theories of Programming Languages},
  doi       = {10.1017/CBO9780511626364},
  publisher = {Cambridge University Press},
  author    = {Reynolds, John C.},
  year      = {1998}
}

@inproceedings{reynolds_coherence,
  author    = {Reynolds, John C.},
  editor    = {Ito, Takayasu
               and Meyer, Albert R.},
  title     = {The coherence of languages with intersection types},
  booktitle = {Theoretical Aspects of Computer Software},
  year      = {1991},
  publisher = {Springer Berlin Heidelberg},
  address   = {Berlin, Heidelberg},
  pages     = {675--700},
  abstract  = {When a programming language has a sufficiently rich type structure, there can be more than one proof of the same typing judgement; potentially this can lead to semantic ambiguity since the semantics of a typed language is a function of such proofs. When no such ambiguity arises, we say that the language is coherent. In this paper we prove the coherence of a class of lambda-calculus-based languages that use the intersection type discipline, including both a purely functional programming language and the Algol-like programming language Forsythe.},
  isbn      = {978-3-540-47617-7}
}

@article{smithinference,
  author = {Smith, Geoffrey},
  year   = {1991},
  month  = {01},
  pages  = {},
  title  = {Polymorphic type inference for languages with overloading and subtyping /}
}

@mastersthesis{springer,
  author = {Springer, Justus},
  school = {University of T\"ubingen},
  title  = {Algebraic Subtyping for Data and Codata},
  year   = {2021},
  type   = {Bachelor's Thesis}
}

@article{subtyping,
  author     = {Liskov, Barbara H. and Wing, Jeannette M.},
  title      = {A Behavioral Notion of Subtyping},
  year       = {1994},
  issue_date = {Nov. 1994},
  publisher  = {Association for Computing Machinery},
  address    = {New York, NY, USA},
  volume     = {16},
  number     = {6},
  issn       = {0164-0925},
  url        = {https://doi.org/10.1145/197320.197383},
  doi        = {10.1145/197320.197383},
  abstract   = {The use of hierarchy is an important component of object-oriented design. Hierarchy allows the use of type families, in which higher level supertypes capture the behavior that all of their subtypes have in common. For this methodology to be effective, it is necessary to have a clear understanding of how subtypes and supertypes are related. This paper takes the position that the relationship should ensure that any property proved about supertype objects also holds for its subtype objects. It presents two ways of defining the subtype relation, each of which meets this criterion, and each of which is easy for programmers to use. The subtype relation is based on the specifications of the sub- and supertypes; the paper presents a way of specifying types that makes it convenient to define the subtype relation. The paper also discusses the ramifications of this notion of subtyping on the design of type families.},
  journal    = {ACM Trans. Program. Lang. Syst.},
  month      = {nov},
  pages      = {1811-1841},
  numpages   = {31},
  keywords   = {formal specifications, subtyping, Larch}
}

@inproceedings{wadlerblott,
  author    = {Wadler, P. and Blott, S.},
  title     = {How to Make Ad-Hoc Polymorphism Less Ad Hoc},
  year      = {1989},
  isbn      = {0897912942},
  publisher = {Association for Computing Machinery},
  address   = {New York, NY, USA},
  url       = {https://doi.org/10.1145/75277.75283},
  doi       = {10.1145/75277.75283},
  abstract  = {This paper presents type classes, a new approach to ad-hoc polymorphism. Type classes permit overloading of arithmetic operators such as multiplication, and generalise the “eqtype variables” of Standard ML. Type classes extend the Hindley/Milner polymorphic type system, and provide a new approach to issues that arise in object-oriented programming, bounded type quantification, and abstract data types. This paper provides an informal introduction to type classes, and defines them formally by means of type inference rules.},
  booktitle = {Proceedings of the 16th ACM SIGPLAN-SIGACT Symposium on Principles of Programming Languages},
  pages     = {60-76},
  numpages  = {17},
  location  = {Austin, Texas, USA},
  series    = {POPL '89}
}

@inproceedings{wadlertheorems,
  author    = {Wadler, Philip},
  title     = {Theorems for Free!},
  year      = {1989},
  isbn      = {0897913280},
  publisher = {Association for Computing Machinery},
  address   = {New York, NY, USA},
  url       = {https://doi.org/10.1145/99370.99404},
  doi       = {10.1145/99370.99404},
  booktitle = {Proceedings of the Fourth International Conference on Functional Programming Languages and Computer Architecture},
  pages     = {347–359},
  numpages  = {13},
  location  = {Imperial College, London, United Kingdom},
  series    = {FPCA '89}
}

@inproceedings{weirich2000,
  author    = {Weirich, Stephanie},
  year      = {2000},
  month     = {11},
  pages     = {92-106},
  title     = {{Encoding Intensional Type Analysis}},
  booktitle = {Proceedings of the 10th European Symposium on Programming Languages and Systems},
  isbn      = {978-3-540-41862-7},
  doi       = {10.1007/3-540-45309-1_7}
}