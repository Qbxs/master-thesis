%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
% Introduction
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

\chapter{Introduction}\label{ch:intro}

Abstraction is a powerful method to generalize code for different use cases.
It can help in hiding implementation details, facilitates the reusage of code and makes it easier to reason about programs.

Abstraction over types has been done in various ways to face different challenges.
Parametric polymorphism can generalize programs that ignore the implementation or representation of their arguments and result,
subtyping allows to use a more specific type when a more loose one is expected
and type classes allow us to implement traits of types individually while still exhibiting a common type constraint for them.
All these forms of polymorphism have a reasoning principle attached to them which allows us to make certain predictions about their behavior.
In order to guarantee this reasoning to be sound, certain constraints have to be enforced when implementing these forms of polymorphism in a language.

While paramtric polymorphism has already been succesfully combined with subtyping as algebraic subtyping \cite{dolan2017subtyping}
and type class (as a form of ad-hoc polymorphism) are a proven feature programming languages such as Haskell \cite{wadlerblott} which is based on the parametric polymorphic Hindley-Milner type system,
the advantages and shortcomings of combining all three together is still unknown.

It is particularily interesting to see how type classes (or more generally predicates on types) are inherited or transfered via the subtyping relation.
If $\Nat$ is a subtype of $\Int$ and we know that $\Int$ is a showable type, does it follow that $\Nat$ is showable as well?
If so, does this hold for all type classes or predicates?
Can we perhaps combine multiple instances to derive at a composed instance for e.g. a union type?

% this section likely needs a big overhaul
In many functional programming languages such as Haskell, type classes are a powerful tool to generalize functions over different data types.
This allows us e.g. to use the \mintinline{Haskell}|+| operator both on \mintinline{Haskell}|Int| and \mintinline{Haskell}|Float| types.
Another approach to overloading functions is subtyping, i.e. if a value of a certain type is expected we can also supply a value of a more specific type that is subsumed by the general type.
For example, since the type of natural numbers \mintinline{text}|Nat| is a subtype of the integers \mintinline{text}|Int|, we can supply a value of type \mintinline{text}|Nat| for any function that expects an \mintinline{text}|Int|.

Although these approaches do not serve exactly the same purpose it is uncommon to find both concepts in the same language.
In this work, I am going to show how it is possible to implement type classes in a language that supports subtyping.
There are unique challenges when bringing both together because instances for certain types are going to be ambiguous and impose additional challenges for the problem of type class coherence.

The Haskell type \mintinline{Haskell}|Either a b| very roughly corresponds to the lattice type \mintinline{text}|a \/ b|  in the sense that both types unify two simpler types.
Given a type class \mintinline{Haskell}|C :: * -> *| and instances \mintinline{Haskell}|C a| and \mintinline{Haskell}|C b| the instance \mintinline{Haskell}|C (Either a b)| has to be defined by hand which can be easily done by pattern-matching and using the given instances.
However, instances for lattice types are neither explicit nor straightforward:
Since \mintinline{text}|a \/ b| does not have a uniquely-determined(?) constructor we might just implicitly derive \mintinline{text}|C (a \/ b)| from the given instances.
However, this would make instances undecidable if we later on decide to implement an explicit instance of \mintinline{text}|C (a \/ b)|.

Together with subtyping we may be able to overload type classes even more.
Consider
\begin{minted}{text}
    Show(if b then 42 : Nat else "Hello World" : String)
\end{minted}
This term of type \mintinline{text}{Nat \/ String} appears to be well typed iff we can resolve the type class instances for \mintinline{text}{Show Nat} and \mintinline{text}{Show String}.

In the following we will explore how type classes interact with these and other lattice types.
