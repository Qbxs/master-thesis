\chapter{Type Inference}
\label{ch:type-inference}
% explain type inference with algebraic subtyping/bounds/bisubstitutions

\section{Bisubstitution}
% can be deleted

For type inference of type class methods we have to consider the appropiate bounds for the unification variable in question.
I.e. for covariant type classes we need to be able to resolve an instance for the upper bounds,
and for covariant type classes we need to resolve an instance for the lower bounds.

\section{Typing Rules}

\begin{figure}[h]
\begin{center}
\AxiomC{}
\RightLabel{\textsc{T-Var}}
\UnaryInfC{$\Gamma, x : \tau \vdash x : \tau$}
\DisplayProof
{\hskip.2in}
\AxiomC{$\ctx e_1 : \sigma \to \tau$}
\AxiomC{$\ctx e_2 : \sigma$}
\RightLabel{\textsc{T-App}}
\BinaryInfC{$\ctx e_1 \; e_2 : \tau$}
\DisplayProof

\AxiomC{$\Gamma, x : \sigma \vdash e : \tau$}
\RightLabel{\textsc{T-Abs}}
\UnaryInfC{$\ctx \lambda x.e : \sigma \to \tau$}
\DisplayProof
{\hskip.2in}
\AxiomC{$\ctx e : \sigma$}
\AxiomC{$\sigma \sub \tau$}
\RightLabel{\textsc{T-Sub}}
\BinaryInfC{$\ctx e : \tau$}
\DisplayProof
\end{center}
\caption{Typing Rules}
\label{fig:typing-rules}
\end{figure}

The resolution rules for type class witnesses in section \ref{sec:witnesses} provide us with means to implement type checking for type class methods.
For every call to a type class method resolution either fails or provides a dictionary, i.e. a witness, for the type class constraint.

What makes this kind of typing derivation special is that it not only decomposes judgements upwards,
but fills in the gap displayed by the type class constraint downwards by resolving a fitting dictionary.

Type inference for type class method calls (fig. \ref{fig:showable-example}):
$w$ is the implicit witness for the type class constraint $\Showable(\tau)$ which is inferred by type class resolution.
$k$ is the continuation that is passed to the type class method.

Generally we generate constraints between the types introduced in the class declaration of the method and the unification variables generated for its arguments.

\begin{figure}[h]
    \centering
    \AxiomC{$\tau$ fresh}
    \AxiomC{$\ctx w : \Showable(\tau)$}
    \AxiomC{$\ctx x : \tau$}
    \AxiomC{$\ctx k : \String \to \sigma$}
    \RightLabel{\textsc{T-Class}}
    \QuaternaryInfC{$\ctx \showTerm w \; x \; k : \sigma$}
    \DisplayProof
\caption{Derivation for $\showTerm w \; x \; k : \sigma$}
\label{fig:showable-example}
\end{figure}

Outlined below is the algorithm used to infer a principle(?) type for any given term without the presence of type classes.
We will then examine, which alterations need to be done in order to achieve the same with the addition of type class constraints.

\subsection{Constraint Generation}


\begin{figure}[h]
\begin{center}
    $\constraintGen{\alpha}_\tau^\bot := \alpha$ \\
    $\constraintGen{\alpha}_\tau^\top := \alpha$ \\
    $\constraintGen{\nu \to \nu'}_\tau^\bot := \constraintGen{\nu}_\tau^\top \to \constraintGen{\nu'}_\tau^\bot$ \\
    $\constraintGen{\nu \to \nu'}_\tau^\top := \constraintGen{\nu}_\tau^\bot \to \constraintGen{\nu'}_\tau^\top$ \\
    $\constraintGen{\mu\alpha.\nu}_\tau^\bot := \mu\alpha.\constraintGen{\nu}_\tau^\bot$ \\
    $\constraintGen{\mu\alpha.\nu}_\tau^\top := \mu\alpha.\constraintGen{\nu}_\tau^\top$ \\
\end{center}
\caption{Constraint Generation?}
\label{fig:constraint-generation'}
\end{figure}

\begin{figure}[h]
    \begin{center}
        placeholder: rules for generating constraint sets
    \end{center}
    \caption{Constraint Generation}
    \label{fig:constraint-generation}
\end{figure}

\subsection{Constraint Solving}

\begin{figure}[h]
    \begin{center}
        placeholder: rules for solvinf constraints
        \begin{itemize}
            \item cache hits
            \item adding to lower/upper bounds
            \item decomposing
            \item fail
        \end{itemize}
    \end{center}
    \caption{Constraint Solving}
    \label{fig:constraint-solving}
\end{figure}

\begin{figure}[h]
    % We might add witnesses here?
    \begin{flalign*}
        \decompose{\tau}{\top} & := & \emptyset \\
        \decompose{\bot}{\tau} & := & \emptyset \\
        \decompose{\tau_1 \join \tau_2}{\sigma} & := & \{ \tau_1 \sub \sigma, \tau_2 \sub \sigma \} \\
        \decompose{\sigma}{\tau_1 \meet \tau_2} & := & \{ \sigma \sub \tau_1, \sigma \sub \tau_2 \} \\
        \decompose{\tau}{\mu\alpha.\sigma} & := & \{ \tau \sub \sigma[\mu\alpha.\sigma / \alpha] \} \\
        \decompose{\mu\alpha.\sigma}{\tau} & := & \{ \sigma[\mu\alpha.\sigma / \alpha] \sub \tau \} \\
        \decompose{\alpha}{\alpha} & := & \emptyset \\
        \decompose{\sigma_1 \to \tau_1}{\sigma_2 \to \tau_2} & := & \{ \sigma_2 \sub \sigma_1, \tau_1 \sub \tau_2 \} \\
    \end{flalign*}
    \caption{Constraint Decomposition}
    \label{fig:constraint-decomposition}
\end{figure}

\subsection{Type Simplification}