\chapter{Type Inference} \label{ch:inference}

Type checking of instance declarations:

\begin{mathpar}
  \inferrule{\mathcal{D}}{}
\end{mathpar}

\begin{lstlisting}
  instance Foo Bar { ... }
\end{lstlisting}

  \begin{minted}[escapeinside=??]{text}
    instance ?$\tau$? C {
       Method?$_1$?(?$x_1,...,x_n,k_1,...,k_n$?) => cmd
    };
  \end{minted}

Type checking of type class method calls:

  \begin{prooftree}
    \alwaysNoLine
    \AxiomC{$\mathcal{D}$}
    \alwaysSingleLine
    \UnaryInfC{$x:\sigma \to \tau \to \sigma, y: \tau\vdash \lambda z.xz(yz) : \sigma \to \sigma$}
      \introd
    \UnaryInfC{$x:\sigma \to \tau \to \sigma\vdash \lambda yz.xz(yz) : \tau \to \sigma \to \sigma$}
      \introd
    \UnaryInfC{$\vdash \lambda xyz.xz(yz) : (\sigma \to \tau \to \sigma) \to (\tau \to \sigma \to \sigma)$}
    \AxiomC{$x:\sigma,y:\tau\vdash x : \sigma$}
      \introd
    \UnaryInfC{$x:\sigma\vdash \lambda y.x : \tau \to \sigma$}
      \introd
    \UnaryInfC{$\vdash \lambda xy.x : \sigma \to \tau \to \sigma$}
      \elim
    \BinaryInfC{$\vdash (\lambda xyz.xz(yz)) (\lambda xy.x) : \tau \to \sigma \to \sigma$}
  \end{prooftree}

  % Main thesis for class coherence with subtyping
  Given \texttt{instance C a} and $sub < a$ and $a < sup$, we can neither have \texttt{instance C sub}, nor \texttt{instance C sup}.

  Could we just use the most specific instance? This might have unexpected results.
  E.g. if we have \texttt{NonEmptyList < List}, we may not know during compilation whether \texttt{NonEmptyList} or \texttt{List} is being picked.
  ~Generally to infer the mose specific type seems very hard. In this example filtering a \texttt{NonEmptyList} may or may not return an empty list and we may just have to assume that it is possibly empty.
  This may lead to hard to track behaviour when using overlapping instances.

  We should always check in an instance declaration whether this constraint globally holds. \\
  To guarantee modularity we also have to check this for module imports (possibly hiding instances).

  Discuss instance chains:
  We can relax this constraint by defining an explicit order in which instances should be picked/resolved.
  \cite{morris2010instance}