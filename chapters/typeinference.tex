\chapter{Type Inference} \label{ch:inference}

Type checking of instance declarations:

\begin{mathpar}
  \inferrule{\mathcal{D}}{}
\end{mathpar}

\begin{lstlisting}
  instance Foo Bar { ... }
\end{lstlisting}

  \begin{minted}[escapeinside=??]{text}
    instance ?$\tau$? C {
       Method?$_1$?(?$x_1,...,x_n,k_1,...,k_n$?) => cmd
    };
  \end{minted}


\section{Type classes as predicates over types}

Type classes are a way to \emph{qualifiy} types for certain properties.
E.g. we can say that for a type $\tau$ to fall under the \texttt{Show} type class means that $\tau$ is a showable type.
This means every term $t : \tau$ has some property $\phi$ that is characteristic for $\Phi$.

Using set-theoretic reasoning, we can motivate rules to reason about type classes by how properties are propagated through various type operators and the subtyping relationship.
$\Phi(\tau)$ holds iff for every witness of $\tau$ some characteristic predicate $\phi$ of $\Phi$ holds.
($\Phi$ can stand for a type class, $\phi$ for a class method.)

\begin{definition}
  A \emph{predicate over types} $\Phi$ is specified by a set of properties $\phi_i$.
  For a type $\tau$ the application $\Phi(\tau)$ holds if and only if $\phi$ holds for every member of $\tau$.
\end{definition}

Our syntax looks as follows:

\begin{flalign*}
  \tau := & \; \texttt{Nat} \; | \; \texttt{Int} \; | \; \dots                         & \textit{Simple types} \\
          & \; \top \; | \; \bot \; | \; \tau \meet \tau \; | \; \tau \join \tau & \textit{Lattice types} \\
  \Phi := & \; \texttt{Read} \; | \; \texttt{Eq} \; | \; \texttt{Show} \; | \; \dots  & \textit{Type classes} \\
  \Xi  := & \; \Phi(\tau) \; | \;  \Xi \Rightarrow \Phi(\tau) & \textit{Constraints}
\end{flalign*}

Deriving instances from super types. If some property holds for $\sigma$ and $\tau < \sigma$,
then since all witnesses of $\tau$ are also witnesses of $\sigma$, the property $\Phi$ is propagated to $\tau$.

Let context $\Gamma = \{ \Xi_1, \dots, \Xi_n \}$ be a set of constraints (propositions).

If $\Phi$ is a property for both $\sigma$ and $\tau < \sigma$, then it should also be a property $\tau$.

  \begin{prooftree}
    \alwaysNoLine
    \AxiomC{$\ctx \Phi(\sigma)$}
    \AxiomC{$\tau :< \sigma$}
    \alwaysSingleLine
    \RightLabel{\textsc{Sub}}
    \BinaryInfC{$\ctx \Phi(\tau)$}
  \end{prooftree}

  If $\Phi$ is a property for both $\tau$ and $\sigma$, then it should also be a property of their union or join $\tau \join \sigma$.

  \begin{prooftree}
    \alwaysNoLine
    \AxiomC{$\ctx \Phi(\sigma)$}
    \AxiomC{$\ctx \Phi(\tau)$}
    \alwaysSingleLine
    \joinRule
    \BinaryInfC{$\ctx \Phi(\tau\join\sigma)$}
  \end{prooftree}

  We can also weaken this rule:
  Since for any $\tau$ and $\sigma$ we have $\tau < \tau \join \sigma$ and $\sigma < \tau \join \sigma$.

  \begin{prooftree}
    \alwaysNoLine
    \AxiomC{$\ctx \Phi(\tau)$}
    \alwaysSingleLine
    \joinRule
    \UnaryInfC{$\ctx \Phi(\tau\join\sigma)$}
  \end{prooftree}

  \begin{prooftree}
    \alwaysNoLine
    \AxiomC{$\ctx \Phi(\sigma)$}
    \alwaysSingleLine
    \joinRule
    \UnaryInfC{$\ctx \Phi(\tau\join\sigma)$}
  \end{prooftree}

  If we know $\Phi$ for both $\tau$ and $\sigma$, the characteristic predicate also holds for all terms that are witnesses of both $\tau$ and $\sigma$, i.e. $\tau\meet\sigma$.
 
  \begin{prooftree}
    \alwaysNoLine
    \AxiomC{$\ctx \Phi(\sigma)$}
    \AxiomC{$\ctx \Phi(\tau)$}
    \alwaysSingleLine
    \meetRule
    \BinaryInfC{$\ctx \Phi(\tau\meet\sigma)$}
  \end{prooftree}

  If $\Phi$ depends on $\Psi$, then for every $\tau$ with $\Phi(\tau)$ we also obtain $\Psi(\tau)$

  \begin{prooftree}
    \AxiomC{$\ctx \Psi(\tau)$}
    \AxiomC{$\ctx \Phi(\tau) \Rightarrow \Psi(\tau)$}
    \RightLabel{\textsc{Impl}}
    \BinaryInfC{$\Gamma \vdash \Phi(\tau)$}
  \end{prooftree}

  Axioms:
  \begin{prooftree}
    \AxiomC{}
    \RightLabel{\textsc{Axiom}}
    \UnaryInfC{$\Gamma, \Xi \vdash \Xi$}
  \end{prooftree}

  Every property holds for all witnesses of $\bot$, so every predicate trivially holds for $\bot$.

  \begin{prooftree}
    \AxiomC{}
    \botRule
    \UnaryInfC{$\Gamma \vdash \Phi(\bot)$}
  \end{prooftree}

  % TODO mention \Gamma in rules and use definition of predicates

\section{Instance Resolution}
% single param type classes

With the Curry-Howard isomorphism we can interpret propositions as types and terms as proofs accordingly.
Extending this notion we can interpret type classes as predicates over types.
E.g. \texttt{Eq} $\sigma$ would mean that the predicate (or property) of equality holds for type $\sigma$.
We can provide a proof for this iff we can resolve an instance of \texttt{Eq} $\sigma$ as a witness.

\begin{flalign*}
  \tau := & \; \texttt{Nat} \; | \; \texttt{Int} \; | \; \dots                         & \textit{Simple types} \\
          & \; \top \; | \; \bot \; | \; \tau \meet \tau \; | \; \tau \join \tau & \textit{Lattice types} \\
  \Phi := & \; \texttt{Read} \; | \; \texttt{Eq} \; | \; \texttt{Show} \; | \; \dots  & \textit{Type classes}
\end{flalign*}

Notation:
\begin{itemize}
  \item $\Gamma$: Context of known instances.
  \item $\Phi^+$: Covariant type class $\Phi$
  \item $\Phi^-$: Contravariant type class $\Phi$
  \item Rules annotated with * constrain the argument types to be equal, e.g. if we can infer $\texttt{Eq}(\tau\join\sigma)$, both arguments of the class method \texttt{Eq} have to be either of type $\tau$ or $\sigma$. 
\end{itemize}

Deriving instances:

  \begin{prooftree}
    \alwaysNoLine
    \AxiomC{$\ctx \Phi^+(\sigma)$}
    \AxiomC{$\tau :< \sigma$}
    \alwaysSingleLine
    \subPosRule
    \BinaryInfC{$\ctx \Phi^+(\tau)$}
  \end{prooftree}

  \begin{prooftree}
    \alwaysNoLine
    \AxiomC{$\ctx \Phi^-(\sigma)$}
    \AxiomC{$\sigma :< \tau$}
    \alwaysSingleLine
    \subNegRule
    \BinaryInfC{$\ctx \Phi^-(\tau)$}
  \end{prooftree}

  Admissable rules:

  Unclear yet, how this behaves for co-/contravariant type classes. Definetly problematic for \texttt{Eq}.
  \begin{prooftree}
    \alwaysNoLine
    \AxiomC{$\ctx \Phi^-(\sigma)$}
    \AxiomC{$\ctx \Phi^-(\tau)$}
    \alwaysSingleLine
    \joinRule
    \BinaryInfC{$\ctx \Phi^-(\tau\join\sigma)$}
  \end{prooftree}

  This seems trivial, because we already have \textsc{Sub}.
  Additionally, given type class coherence the meet would always be $\bot$. So we do not gain anything from this rule.
  \begin{prooftree}
    \alwaysNoLine
    \AxiomC{$\ctx \Phi^+(\sigma)$}
    \AxiomC{$\ctx \Phi^+(\tau)$}
    \alwaysSingleLine
    \meetRule
    \BinaryInfC{$\ctx \Phi^+(\tau\meet\sigma)$}
  \end{prooftree}

  Axioms:
  \begin{prooftree}
    \AxiomC{}
    \axiomPos
    \UnaryInfC{$\Gamma, \Phi^+(\tau) \vdash \Phi^+(\tau)$}
  \end{prooftree}

  \begin{prooftree}
    \AxiomC{}
    \axiomNeg
    \UnaryInfC{$\Gamma, \Phi^-(\tau) \vdash \Phi^-(\tau)$}
  \end{prooftree}

  This seems trivial again:

  \begin{prooftree}
    \AxiomC{}
    \botRule
    \UnaryInfC{$\Gamma \vdash \Phi^+(\bot)$}
  \end{prooftree}

  This seems very questionable (but does not entail obviously wrong things with \textsc{Sub}$^-$):

  \begin{prooftree}
    \AxiomC{}
    \topRule
    \UnaryInfC{$\Gamma \vdash \Phi^-(\top)$}
  \end{prooftree}

  Probably should not be a rule:
  \begin{prooftree}
    \alwaysNoLine
    \AxiomC{\texttt{instance }$\Phi(\tau)$}
    \alwaysSingleLine
    \instanceDeclRule
    \UnaryInfC{$\Phi(\tau) \vdash$}
  \end{prooftree}

\section{Dictionary Passing}

One typical way of implementing type classes is using \emph{dicitonary passing style}.
Here, the instances of a type class are carried in a dictionary that has to be passed as an additional argument to method calls.
For example the term

\begin{minted}{Haskell}
  show 5
\end{minted}

would be compiled to

\begin{minted}{Haskell}
  show showIntDict 5
\end{minted}

where \mintinline{Haskell}|showIntDict| is a dictionary that provides the relevant defintion of \mintinline{Haskell}{show :: Int -> String} for the instance of \mintinline{Haskell}|Show Int|.

There is a drawback however, in the presence of subtyping it may not always be clear which dictionary is going to be needed for instance resolution.
Consider the term:

\begin{minted}{text}
  show (if b then 42 :: Int else "Hello" :: String)
\end{minted}

The inferred type of this expression should be \mintinline{text}{Int \/ String}.
What we need here are essentially two dictionaries: One for \mintinline{text}{Int} and one for \mintinline{text}{String}.

\section{Intensional type analysis}

Instead of passing around dictionaries, we can also resolve the relevant instance at runtime dispatching on the term's type.
In the before mentioned case, the definition of \mintinline{Haskell}{show} could look something like this:

\begin{minted}{Haskell}
  show t x = case t of
    Bool -> boolShow x
    Int -> intShow x
\end{minted}

In the context of subtyping we would not require type equality but for \mintinline{Haskell}{t} to be a subtype of some type for which an instance is defined.

\section{Misc}

  % Main thesis for class coherence with subtyping
  Given \texttt{instance C a} and $sub < a$ and $a < sup$, we can neither have \texttt{instance C sub}, nor \texttt{instance C sup}.

  Consider we have \texttt{Nat :< Int}.
  We can implement Monoid instances for both types. For natural numbers we choose multiplication as operator and accordingly 1 as neutral element.
  For integers on the other hand, we might prefer to choose addition as operator and 0 as neutral element, so we can expand to monoid to a group.

  Building programs on top of these instances is going to get tedious as it will often occur that the more specific \texttt{Nat} type will be inferred,
  even if only want to deal with integers.
  Using the append operator exposed by the Monoid typeclass, therefore may lead to unexpected behavior.
  % Note for a good example, we need a good notion of type inference for this case, which is currently not implemented.

  In the simple arithmetic expression $(a \oplus b) \oplus c$ $\oplus$ can have two different meanings based on the inferred types of $a,b$ and $c$.
  Since type inferrence with subtyping is generally not quite obvious it may seem 

  Could we just use the most specific instance? This might have unexpected results.
  E.g. if we have \texttt{NonEmptyList < List}, we may not know during compilation whether \texttt{NonEmptyList} or \texttt{List} is being picked.
  ~Generally to infer the most specific type seems very hard. In this example filtering a \texttt{NonEmptyList} may or may not return an empty list and we may just have to assume that it is possibly empty.
  This may lead to hard to track behaviour when using overlapping instances.

  We should always check in an instance declaration whether this constraint globally holds. \\
  To guarantee modularity we also have to check this for module imports (possibly hiding instances).

  Discuss instance chains:
  We can relax this constraint by defining an explicit order in which instances should be picked/resolved.
  \cite{morris2010instance}