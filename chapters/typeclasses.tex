\chapter{Type Classes}\label{ch:typeclasses}

In order to generalize functions over data types there have been several proposals to abstract over types in different programming languages:
Amongst others,
\begin{itemize}
\item Parametric polymorphism: we can define functions without knowing the concrete representation of the arguments and result types (e.g. \texttt{id : a -> a}) % cite something
\item ad-hoc polymorphism: in some mostly imperative languages it is possible to simply overload functions (e.g. we may define \texttt{+} both on integers and on float values, the correct implementation is then picked based on the argument type) % cite...
\item and type classes. Combining both approaches (making ad-polymorphism less ad-hoc) we can define classes and corresponding functions and then use them to constrain valid argument types when defining a function that relies on these type class functions \cite{wadlerblott}
\end{itemize}

\section{Type Classes}\label{sec:typeclasses}
% overloading vs type classes
% paper by wadler

If our type system doesn't allow for ad-hoc polymorphism it may seem neccessary to write verbose code for basic function with respect to every concrete type it should be used for.
An intuitive example for this (that is also the motivation for type classes in the original proposal) are arithmetic operators.
We simply cannot define \texttt{(+) : Int -> Int -> Int} and then also \texttt{(+) : Float -> Float -> Float} in a different implementation, on which both types definetly rely on under the hood.
But these types have nonetheless something in common. Namely that they both stand for \emph{numerical} values, that hence support the usual arithmetic operations, like addition, multiplication, division and so on.

The idea of type classes is to generalise attributes of types with appropriate function.
The class \mintinline{Haskell}|Num| in Haskell expects that we can implement a number of numerical functions for a type $\tau$ if it is ought to be a member of the \mintinline{Haskell}|Num| type class.

Shortened definition of the \mintinline{Haskell}|Num| type class in Haskell.
\footnote{As can be found in the default \texttt{Prelude}: \url{https://hackage.haskell.org/package/base-4.16.2.0/docs/Prelude.html\#t:Num}}

\begin{minted}{Haskell}
class  Num a  where
    (+), (-), (*) :: a -> a -> a
\end{minted}

An instance would look like:

\begin{minted}{Haskell}
instance  Num Int  where
    (+) = intAdd
    (-) = intMinus
    (*) = intMul
\end{minted}





% later:
% category theory: functors, monoids, monads, etc.

In the end, this enables us to use elaborate concepts such as functors and monads to reason about programs.

\cite{wadlerblott}

\section{Multi parameter type classes}\label{sec:multiparam}

\section{The problem of type class coherence}\label{sec:coherence}
% for each type there t may be globally at most one instance C t defined
% discuss overlapping instances
% can already be tricky in a modular system
% more challenging with subtyping

Even though the general concept of type classes introduces a general meaning for each type class.
The evaluation still strongly depends on implementation details found in specific instances.
For example, for the \texttt{Ord} type class we may choose to implement the ordering in ascending or descending order.
It is therefore crucial, that for each type the corresponding instance - if it exists - is uniquely determined by the type.

Reynolds \cite{reynolds_coherence}:

\begin{quote}
    When a programming language has a sufficiently rich type structure, there can be more than one proof of the same
    typing judgment; potentially this can lead to semantic ambiguity since the semantics of a typed language is a function
    of such proofs. When no such ambiguity arises, we say that the language is coherent.
\end{quote}

In the Haskell98 standard, type class coherence is guaranteed by the syntactical equivalence of resolved instances.
For each Haskell type there may be at most one instance defined for each type class.

Ambiguous programs should therefore generally be rejected.
One example, also mentioned in the Haskell 98 report \cite{Haskell98} is this short program which simply reads a string to a data type and then converts it back to string without specifying which data type is being used:

\begin{minted}{Haskell}
    f :: String -> String
    f str = let x = read str in show x
\end{minted}

There may be multiple types that satisfy the type class constraints.
The specific implementation of \mintinline{Haskell}{show :: forall a. (Show a) => a -> String} and \mintinline{Haskell}{read :: forall a.(Read a) -> String -> a} is therefore unknown.


\begin{tikzcd}
    &  & \mintinline{Haskell}|Ord (Maybe a)| \arrow[llddd, "{\footnotesize\mintinline{Haskell}|class Eq a => Ord a|}"'] \arrow[rrddd, "{\footnotesize\mintinline{Haskell}|instance Ord a => Ord (Maybe a)|}"] &  &                            \\
    &  &                                &  &                            \\
    &  &                                &  &                            \\
    \mintinline{Haskell}|Eq (Maybe a)| \arrow[rrddd, "{\footnotesize\mintinline{Haskell}|instance Eq a => Eq (Maybe a)|}"'] &  &                                &  & \mintinline{Haskell}|Ord a| \arrow[llddd, "{\footnotesize \mintinline{Haskell}|class Eq a => Ord a|}"] \\
    &  &                                &  &                            \\
    &  &                                &  &                            \\
    &  & \mintinline{Haskell}|Eq a|                  &  &                           
\end{tikzcd}

Even though there are multiple ways to derive an instance for \mintinline{Haskell}|Eq a| from an instance of \texttt{Ord (Maybe a)}, the derived instance has to be uniquely determined.
Since the diagram commutes, there has to be exactly one instance for \mintinline{Haskell}|Eq a|.

Uniqueness or non-ambiguity of type classes.
