\chapter{Qualified Types} \label{ch:qualified-types}

\section{Theory of Predicates}

To reason about ad-hoc polymorhism we talk about \emph{qualified types}, i.e. types that satisfy some predicate.

\begin{definition} Predicates\\
  Given a universe of types $\mathcal{U}$, a \emph{predicate over types} $\Phi$ is an element of $\mathcal{P}(\mathcal{U})$.
\end{definition}

There can be many different kinds of predicates over types, however not all of them are useful in the context of subtyping.


We are only interested in predicates that are preserved over the subtyping lattice.
I.e. predicates that depend only on the witnesses of a type.
That means only predicates that are \emph{monotonous} are considered while other predicates such as \emph{"has exactly two values"} are disregarded.
We further differentiate between \emph{covariant} and \emph{contravariant} predicates over types.

Let $\Gamma$ be the context of facts, i.e. known types that satisfy specific predicates.

\begin{definition}
  A \emph{covariant type class predicate} $\Phi^+$ is a predicate preserved by the subtyping relation, i.e. it adheres to the following rule:
\end{definition}

% The monotonicity of $\Phi^+$ motivates the following rule preserving the predicate for subtypes.
% From the definition of covariant predicates it follows that $\phi$ holds for every witness of $\sigma$ and because every witness of $\tau$ is also a witness of $\sigma$ the characteristic property $\phi$ holds for all witnesses of $\tau$.

\begin{prooftree}
  \alwaysNoLine
  \AxiomC{$\ctx \Phi^+(\sigma)$}
  \AxiomC{$\tau \sub \sigma$}
  \alwaysSingleLine
  \RightLabel{\textsc{Sub}$^+$}
  \BinaryInfC{$\ctx \Phi^+(\tau)$}
\end{prooftree}

With \textsc{Sub}$^+$ and the subtyping rules we can derive several useful rules:

\begin{center}
  \alwaysNoLine
  \AxiomC{$\ctx \Phi^+(\top)$}
  \alwaysSingleLine
  \RightLabel{\textsc{Top}$^+$}
  \UnaryInfC{$\ctx \Phi^+(\tau)$}
  \DisplayProof
  {\hskip.2in}
  \alwaysNoLine
  \AxiomC{$\ctx \Phi^+(\tau)$}
  \alwaysSingleLine
  \RightLabel{\textsc{Bot}$^+$}
  \UnaryInfC{$\ctx \Phi^+(\bot)$}
  \DisplayProof
\end{center}

\begin{center}
  \alwaysNoLine
  \AxiomC{$\ctx \Phi^+(\tau)$}
  \alwaysSingleLine
  \RightLabel{\textsc{Meet}$_1^+$}
  \UnaryInfC{$\ctx \Phi^+(\tau \meet \sigma)$}
  \DisplayProof
  {\hskip.2in}
  \alwaysNoLine
  \AxiomC{$\ctx \Phi^+(\sigma)$}
  \alwaysSingleLine
  \RightLabel{\textsc{Meet}$_2^+$}
  \UnaryInfC{$\ctx \Phi^+(\tau \meet \sigma)$}
  \DisplayProof
\end{center}

\begin{prooftree}
  \AxiomC{$\ctx \Phi^+(Int)$}
  \alwaysSingleLine
  \RightLabel{\textsc{Prim}$^+$}
  \UnaryInfC{$\ctx \Phi^+(Nat)$}
\end{prooftree}

\begin{definition}
  A \emph{contravariant type class predicate} $\Phi^-$ is a predicate preserved by the supertyping or flipped subtyping relation, i.e. it adheres to the following rule:
\end{definition}

\begin{prooftree}
  \alwaysNoLine
  \AxiomC{$\ctx \Phi^-(\sigma)$}
  \AxiomC{$\sigma \sub \tau$}
  \alwaysSingleLine
  \RightLabel{\textsc{Sub}$^-$}
  \BinaryInfC{$\ctx \Phi^-(\tau)$}
\end{prooftree}

The rules for contravariant predicates are dual to those for covariant predicates.
The monotonicity of $\Phi^-$ motivates the following rule preserving the predicate for supertypes:
From the definition of contravariant predicates it follows that $\phi$ holds for some witness of $\sigma$ and because every witness of $\sigma$ is also a witness of $\tau$ there is at least one witness of $\tau$ for which the characteristic property $\phi$ holds.

% derivable statt admissable
With \textsc{Sub}$^-$ and the subtyping rules we can again derive several useful rules:

\begin{center}
  \alwaysNoLine
  \AxiomC{$\ctx \Phi^-(\tau)$}
  \alwaysSingleLine
  \RightLabel{\textsc{Top}$^-$}
  \UnaryInfC{$\ctx \Phi^-(\top)$}
  \DisplayProof
  {\hskip.2in}
  \alwaysNoLine
  \AxiomC{$\ctx \Phi^-(\bot)$}
  \alwaysSingleLine
  \RightLabel{\textsc{Bot}$^-$}
  \UnaryInfC{$\ctx \Phi^-(\tau)$}
  \DisplayProof
\end{center}

\begin{center}
  \alwaysNoLine
  \AxiomC{$\ctx \Phi^-(\tau)$}
  \alwaysSingleLine
  \RightLabel{\textsc{Join}$_1^-$}
  \UnaryInfC{$\ctx \Phi^-(\tau \join \sigma)$}
  \DisplayProof
  {\hskip.2in}
  \alwaysNoLine
  \AxiomC{$\ctx \Phi^-(\sigma)$}
  \alwaysSingleLine
  \RightLabel{\textsc{Join}$_2^-$}
  \UnaryInfC{$\ctx \Phi^-(\tau \join \sigma)$}
  \DisplayProof
\end{center}

\begin{prooftree}
  \AxiomC{$\ctx \Phi^-(Nat)$}
  \alwaysSingleLine
  \RightLabel{\textsc{Prim}$^+$}
  \UnaryInfC{$\ctx \Phi^-(Int)$}
\end{prooftree}

% \begin{center}
%   \alwaysNoLine
%   \AxiomC{$\ctx \Phi^-(\tau \meet \sigma)$}
%   \alwaysSingleLine
%   \RightLabel{\textsc{Meet}$_1^-$}
%   \UnaryInfC{$\ctx \Phi^-(\tau)$}
%   \DisplayProof
%   {\hskip.2in}
%   \alwaysNoLine
%   \AxiomC{$\ctx \Phi^-(\tau \meet \sigma)$}
%   \alwaysSingleLine
%   \RightLabel{\textsc{Meet}$_2^-$}
%   \UnaryInfC{$\ctx \Phi^-(\sigma)$}
%   \DisplayProof
% \end{center}

We omit the $^+$ and $^-$ superscripts if the variance of predicates does not matter.
Using this notation we can simplify axioms and the rule for constraints.
The rule for axioms is trivial: We can resolve known facts directly from the context.

  \begin{prooftree}
    \AxiomC{}
    \RightLabel{\textsc{Axiom}}
    \UnaryInfC{$\Gamma, \Phi(\tau) \vdash \Phi(\tau)$}
  \end{prooftree}

Predicates may be constrained, i.e. they depend on other predicates.
$\Phi(\tau) \Rightarrow \Psi(\tau)$ means $\Psi$ is constrained by $\Phi$.
Thus, if $\Psi(\tau)$ is satisfied, then the constraint $\Phi(\tau)$ is satisfied as well.
Note that this corresponds to implications even though the arrow is flipped as it is oriented towards constraints.

  \begin{prooftree}
    \AxiomC{$\ctx \Psi(\tau)$}
    \AxiomC{$\ctx \Phi(\tau) \Rightarrow \Psi(\tau)$}
    \RightLabel{\textsc{Constr}}
    \BinaryInfC{$\Gamma \vdash \Phi(\tau)$}
  \end{prooftree}

\subsection{Examples}

Consider the predicates $Showable$ and $Defaultable$.
A type $\tau$ satsifies the covariant predicate $Showable$ if for each term a function from $\tau \to String$ is defined.
Dually, a type $\tau$ satsifies the contravariant predicate $Defaultable$ if a function of type $Unit \to \tau$ can be defined.

Let context $\Gamma := \{ Showable(Int \join Unit), Defaultable(Nat) \}$.
We obtain the following derivations for $Showable(Nat)$ and $Defaultable(Int \meet \sigma)$:

\begin{prooftree}
  \AxiomC{}
  \RightLabel{\textsc{Axiom}}
  \UnaryInfC{$\ctx Showable(Int \join Unit)$}
  \RightLabel{\textsc{Join}$^+_1$}
  \UnaryInfC{$\ctx Showable(Int)$}
  \alwaysSingleLine
  \RightLabel{\textsc{Prim}$^+$}
  \UnaryInfC{$\ctx Showable(Nat)$}
\end{prooftree}

\begin{prooftree}
  \AxiomC{}
  \RightLabel{\textsc{Axiom}}
  \UnaryInfC{$\ctx Defaultable(Nat)$}
  \RightLabel{\textsc{Prim}$^-$}
  \UnaryInfC{$\ctx Defaultable(Int)$}
  \alwaysSingleLine
  \RightLabel{\textsc{Meet}$^-_1$}
  \UnaryInfC{$\ctx Defaultable(Int \meet \sigma)$}
\end{prooftree}

\section{Witnesses}

By annotating applications of predicates with specific witnesses we obtain a calculus
that is not only able to prove that a type satisfies a predicate but also constructs a witness for such a proof.


\begin{prooftree}
  \AxiomC{$i : {\bf instance} \; \Phi(\tau)$}
  \RightLabel{\textsc{Decl}}
  \UnaryInfC{$w : \Phi(\tau)$}
\end{prooftree}

\begin{prooftree}
  \AxiomC{$w : \Psi(\tau)$}
  \AxiomC{$s : \Phi(\tau) \Rightarrow \Psi(\tau)$}
  \RightLabel{\textsc{SuperC}}
  \BinaryInfC{$s(w) : \Phi(\tau)$}
\end{prooftree}

\begin{center}
  \alwaysNoLine
  \AxiomC{$w : \Phi^+(\top)$}
  \alwaysSingleLine
  \RightLabel{\textsc{Top}$^+$}
  \UnaryInfC{$triv(w) : \Phi^+(\tau)$}
  \DisplayProof
  {\hskip.2in}
  \alwaysNoLine
  \AxiomC{$w : \Phi^+(\tau)$}
  \alwaysSingleLine
  \RightLabel{\textsc{Bot}$^+$}
  \UnaryInfC{$triv(w) : \Phi^+(\bot)$}
  \DisplayProof
\end{center}

\begin{center}
  \alwaysNoLine
  \AxiomC{$w : \Phi^-(\tau)$}
  \alwaysSingleLine
  \RightLabel{\textsc{Top}$^-$}
  \UnaryInfC{$triv(w) : \Phi^-(\top)$}
  \DisplayProof
  {\hskip.2in}
  \alwaysNoLine
  \AxiomC{$w : \Phi^-(\bot)$}
  \alwaysSingleLine
  \RightLabel{\textsc{Bot}$^-$}
  \UnaryInfC{$triv(w) : \Phi^-(\tau)$}
  \DisplayProof
\end{center}

\begin{center}
  \AxiomC{$in_1(w) : \Phi^+(\tau \join \sigma)$}
  \RightLabel{\textsc{Join}$_1^+$}
  \UnaryInfC{$w : \Phi^+(\tau)$}
  \DisplayProof
  {\hskip.2in}
  \AxiomC{$in_2(w) : \Phi^+(\tau \join \sigma)$}
  \RightLabel{\textsc{Join}$_2^+$}
  \UnaryInfC{$w : \Phi^+(\sigma)$}
  \DisplayProof
\end{center}

% simply reuse the same witness
\begin{center}
  \AxiomC{$proj_1(w) : \Phi^+(\tau)$}
  \RightLabel{\textsc{Meet}$_1^+$}
  \UnaryInfC{$w : \Phi^+(\tau \meet \sigma)$}
  \DisplayProof
  {\hskip.2in}
  \AxiomC{$proj_2(w) : \Phi^+(\sigma)$}
  \RightLabel{\textsc{Meet}$_2^+$}
  \UnaryInfC{$w : \Phi^+(\tau \meet \sigma)$}
  \DisplayProof
\end{center}

\begin{center}
  \AxiomC{$w : \Phi^-(\tau \meet \sigma)$}
  \RightLabel{\textsc{Meet}$_1^-$}
  \UnaryInfC{$proj_1(w) : \Phi^-(\tau)$}
  \DisplayProof
  {\hskip.2in}
  \AxiomC{$w : \Phi^-(\tau \meet \sigma)$}
  \RightLabel{\textsc{Meet}$_2^-$}
  \UnaryInfC{$proj_2(w) : \Phi^+(\sigma)$}
  \DisplayProof
\end{center}

\begin{center}
  \AxiomC{$w : \Phi^-(\tau)$}
  \RightLabel{\textsc{Join}$_1^-$}
  \UnaryInfC{$in_1(w) : \Phi^-(\tau \join \sigma)$}
  \DisplayProof
  {\hskip.2in}
  \AxiomC{$w : \Phi^-(\sigma)$}
  \RightLabel{\textsc{Join}$_2^-$}
  \UnaryInfC{$in_2(w) : \Phi^-(\tau \join \sigma)$}
  \DisplayProof
\end{center}

\section{Coherence}

Using witnesses we may formalize type class coherence:

\begin{definition}
  Type class resolution is coherent if and only if for any pair of witnesses $i,j : \Phi(\tau)$ that witness the same predicate application we have $i \opeq j$.
\end{definition}

TODO: Define operational equality $\opeq$

\section{Inclusive Subtyping}

We assume a naive set-theoretic definition of subtyping analagous to the one given by Castagna and Xu \cite{castagna}:

\begin{definition} Subtyping\\
  $\tau \sub \sigma \Leftrightarrow [\tau] \subseteq [\sigma]$ where $[\tau]$ is the set  of all witnesses of $\tau$.
\end{definition}

This notion of subtyping trivially satsifies the Liskov substitution principle.
Because with $\tau \sub \sigma$ for every $e : \tau$ we also have $e : \sigma$, the coercion function is the identity.
Thus all properties are preserved for terms over the subtyping relation.

The \textsc{Join} rule can not be derived with the subtyping rules because $\tau \join \sigma$ is neither a subtype of $\tau$ nor of $\sigma$.
However, there is a motivation for it:
With the definition of covariant predicates the premises express that for all witnesses of $\tau$ and $\sigma$ the characteristic property holds.
Since every witness of $\tau \join \sigma$ is a witness of $\tau$ or $\sigma$, $\Phi(\tau \join \sigma)$ holds.

\begin{prooftree}
  \alwaysNoLine
  \AxiomC{$\ctx \Phi^+(\sigma)$}
  \AxiomC{$\ctx \Phi^+(\tau)$}
  \alwaysSingleLine
  \RightLabel{\textsc{Join}$^+$}
  \BinaryInfC{$\ctx \Phi^+(\tau\join\sigma)$}
\end{prooftree}


The \textsc{Meet} rule can not be derived with the subtyping rules because $\tau \meet \sigma$ is neither a supertype of $\tau$ nor of $\sigma$.
However, there is a motivation for it:
With the definition of contravariant predicates the premises express that for some witnesses of $\tau$ and $\sigma$ the characteristic property holds.
Since some witness of $\tau \meet \sigma$ is a witness of both $\tau$ and $\sigma$, $\Phi(\tau \meet \sigma)$ holds.
% this rule is bogus:
% if \tau and \sigma are disjoint there is no possible witness in \tau \meet \sigma...

\begin{prooftree}
  \alwaysNoLine
  \AxiomC{$\ctx \Phi^-(\sigma)$}
  \AxiomC{$\ctx \Phi^-(\tau)$}
  \alwaysSingleLine
  \RightLabel{\textsc{Meet}$^-$}
  \BinaryInfC{$\ctx \Phi^-(\tau\meet\sigma)$}
\end{prooftree}


\section{Type classes as predicates over types}

Type classes can be seen as a form of \emph{qualified types}, i.e. types that qualify for certain properties.
E.g. we can say that for a type $\tau$ to fall under the \texttt{Show} type class means that $\tau$ is a showable type.
In this case, it means every term $t : \tau$ has some property $\phi$ that is characteristic for $\Phi$.

In this section we want to give a way to reason about predicates over types and how they can be related in the context of subtyping.
We therefore restrict ourselves to monotonous predicates, i.e. predicates that only refer to the witnesses of types, opposed to e.g. predicates about the number of witnesses of a type.

Using set-theoretic reasoning, we can motivate rules to reason about type classes by how properties are propagated through various type operators and the subtyping relationship.
$\Phi(\tau)$ holds iff for every witness of $\tau$ some characteristic property $\phi$ of $\Phi$ holds.
($\Phi$ can stand for a type class, $\phi$ for a class method.)

\begin{definition}
  A \emph{predicate over types} $\Phi$ is specified by a set of properties $\phi_i$.
  For a type $\tau$ the application $\Phi(\tau)$ holds if and only if $\phi$ holds for every member of $\tau$.
\end{definition}

Our syntax looks as follows:

\begin{flalign*}
  \tau := & \; \texttt{Nat} \; | \; \texttt{Int} \; | \; \dots                         & \textit{Simple types} \\
          & \; \top \; | \; \bot \; | \; \tau \meet \tau \; | \; \tau \join \tau & \textit{Lattice types} \\
  \Phi := & \; \texttt{Read} \; | \; \texttt{Eq} \; | \; \texttt{Show} \; | \; \dots  & \textit{Type classes} \\
  \Xi  := & \; \Phi(\tau) \; | \;  \Xi \Rightarrow \Phi(\tau) & \textit{Constraints}
\end{flalign*}

Let context $\Gamma = \{ \Xi_1, \dots, \Xi_n \}$ be a set of constraints (propositions).

The central rule motivated by Liskov substitution:
If some property holds for $\sigma$ and $\tau \sub \sigma$,
If $\Phi$ is a property for $\sigma$ and $\tau \sub \sigma$, then it should also be a property $\tau$.
Since all witnesses of $\tau$ are also witnesses of $\sigma$, the property $\Phi$ is propagated to $\tau$.

  \begin{prooftree}
    \alwaysNoLine
    \AxiomC{$\ctx \Phi(\sigma)$}
    \AxiomC{$\tau \sub \sigma$}
    \alwaysSingleLine
    \RightLabel{\textsc{Sub}}
    \BinaryInfC{$\ctx \Phi(\tau)$}
  \end{prooftree}

  If $\Phi$ is a property for both $\tau$ and $\sigma$, then it should also be a property of their union or join $\tau \join \sigma$.
  Since all witnesses of $\tau \join \sigma$ are witnesses of $\sigma$ or $\tau$, the property $\Phi$ holds for all witnesses of $\tau \join \sigma$.

  \begin{prooftree}
    \alwaysNoLine
    \AxiomC{$\ctx \Phi(\sigma)$}
    \AxiomC{$\ctx \Phi(\tau)$}
    \alwaysSingleLine
    \joinRule
    \BinaryInfC{$\ctx \Phi(\tau\join\sigma)$}
  \end{prooftree}

  If we know $\Phi$ for both $\tau$ and $\sigma$, the characteristic predicate also holds for all terms that are witnesses of both $\tau$ and $\sigma$, i.e. $\tau\meet\sigma$.
  This rule is \emph{admissable} because with $\tau \sub \tau \meet \sigma$ and $\sigma \sub \tau \meet \sigma$ given by the subtyping rules we can derive the result using the \textsc{Sub}-rule.
 
  \begin{prooftree}
    \alwaysNoLine
    \AxiomC{$\ctx \Phi(\tau)$}
    \alwaysSingleLine
    \meetRule
    \UnaryInfC{$\ctx \Phi(\tau\meet\sigma)$}
  \end{prooftree}

  \begin{prooftree}
    \alwaysNoLine
    \AxiomC{$\ctx \Phi(\sigma)$}
    \alwaysSingleLine
    \meetRule
    \UnaryInfC{$\ctx \Phi(\tau\meet\sigma)$}
  \end{prooftree}

  If $\Phi$ depends on $\Psi$, then for every $\tau$ with $\Phi(\tau)$ we also obtain $\Psi(\tau)$.
  For every witness of $\tau$, the characteristic property $\psi$ holds and because of $\Phi(\tau) \Rightarrow \Psi(\tau)$ we have $\psi$ implies $\phi$, $\phi$ holds for every witness of $\tau$ as well.

  \begin{prooftree}
    \AxiomC{$\ctx \Psi(\tau)$}
    \AxiomC{$\ctx \Phi(\tau) \Rightarrow \Psi(\tau)$}
    \RightLabel{\textsc{Impl}}
    \BinaryInfC{$\Gamma \vdash \Phi(\tau)$}
  \end{prooftree}

  We can also introduce elimination rules for unions.
  These are also \emph{admissable} since for any $\tau$ and $\sigma$ we have with the subtyping rules $\tau \sub \tau \join \sigma$ and $\sigma \sub \tau \join \sigma$ and can then derive this rule from \textsc{Sub}.

  \begin{prooftree}
    \alwaysNoLine
    \AxiomC{$\ctx \Phi(\tau\join\sigma)$}
    \alwaysSingleLine
    \joinRule
    \UnaryInfC{$\ctx \Phi(\tau)$}
  \end{prooftree}

  \begin{prooftree}
    \alwaysNoLine
    \AxiomC{$\ctx \Phi(\tau\join\sigma)$}
    \alwaysSingleLine
    \joinRule
    \UnaryInfC{$\ctx \Phi(\sigma)$}
  \end{prooftree}

  Axioms:
  \begin{prooftree}
    \AxiomC{}
    \RightLabel{\textsc{Axiom}}
    \UnaryInfC{$\Gamma, \Phi(\tau) \vdash \Phi(\tau)$}
  \end{prooftree}

  Every property holds for all witnesses of $\bot$ because there are none, so every predicate trivially holds for $\bot$.

  \begin{prooftree}
    \AxiomC{}
    \botRule
    \UnaryInfC{$\ctx \Phi(\bot)$}
  \end{prooftree}

  If we know $\Phi(\top)$, then with the \textsc{Sub}-rule we can infer $\Phi(\tau)$ for any type $\tau$.

  \begin{prooftree}
    \AxiomC{$\ctx \Phi(\top)$}
    \RightLabel{\textsc{Top}}
    \UnaryInfC{$\ctx \Phi(\tau)$}
  \end{prooftree}

  % TODO mention \Gamma in rules and use definition of predicates

\section{Instance Resolution}
% single param type classes

With the Curry-Howard isomorphism we can interpret propositions as types and terms as proofs accordingly.
Extending this notion we can interpret type classes as predicates over types.
E.g. \texttt{Eq} $\sigma$ would mean that the predicate (or property) of equality holds for type $\sigma$.
We can provide a proof for this iff we can resolve an instance of \texttt{Eq} $\sigma$ as a witness.

Here, we build upon the rules for qualified types to construct resolution rules for type classes.
Our language differentiates between co- and contravariant type classes because they behave differently in the context of subtyping.
Co- and contravariant type classes restrict the occurence of the bound type variable in the methods.

An example for a covariant type class is the \texttt{Read} type class in which the type to be shown only occurs in a covariant position.
In the \texttt{Read} type class the type variable only occurs in a contravariant position. 

\begin{flalign*}
  \tau := & \; \texttt{Nat} \; | \; \texttt{Int} \; | \; \dots                         & \textit{Simple types} \\
          & \; \top \; | \; \bot \; | \; \tau \meet \tau \; | \; \tau \join \tau & \textit{Lattice types} \\
  \Phi := & \; \texttt{Read} \; | \; \texttt{Eq} \; | \; \texttt{Show} \; | \; \dots  & \textit{Type classes}
\end{flalign*}

Notation:
\begin{itemize}
  \item $\Gamma$: Context of known instances.
  \item $\Phi^+$: Covariant type class $\Phi$
  \item $\Phi^-$: Contravariant type class $\Phi$
  \item Rules annotated with * constrain the argument types to be equal, e.g. if we can infer $\texttt{Eq}(\tau\join\sigma)$, both arguments of the class method \texttt{Eq} have to be either of type $\tau$ or $\sigma$. 
\end{itemize}

Deriving instances:

  \begin{prooftree}
    \alwaysNoLine
    \AxiomC{$\ctx \Phi^+(\sigma)$}
    \AxiomC{$\tau \sub \sigma$}
    \alwaysSingleLine
    \subPosRule
    \BinaryInfC{$\ctx \Phi^+(\tau)$}
  \end{prooftree}

  \begin{prooftree}
    \alwaysNoLine
    \AxiomC{$\ctx \Phi^-(\sigma)$}
    \AxiomC{$\sigma \sub \tau$}
    \alwaysSingleLine
    \subNegRule
    \BinaryInfC{$\ctx \Phi^-(\tau)$}
  \end{prooftree}

  Admissable rules:

  Unclear yet, how this behaves for co-/contravariant type classes. Definetly problematic for \texttt{Eq}.
  \begin{prooftree}
    \alwaysNoLine
    \AxiomC{$\ctx \Phi^-(\sigma)$}
    \AxiomC{$\ctx \Phi^-(\tau)$}
    \alwaysSingleLine
    \joinRule
    \BinaryInfC{$\ctx \Phi^-(\tau\join\sigma)$}
  \end{prooftree}

  This seems trivial, because we already have \textsc{Sub}.
  Additionally, given type class coherence the meet would always be $\bot$. So we do not gain anything from this rule.
  \begin{prooftree}
    \alwaysNoLine
    \AxiomC{$\ctx \Phi^+(\sigma)$}
    \AxiomC{$\ctx \Phi^+(\tau)$}
    \alwaysSingleLine
    \meetRule
    \BinaryInfC{$\ctx \Phi^+(\tau\meet\sigma)$}
  \end{prooftree}

  Axioms:
  \begin{prooftree}
    \AxiomC{}
    \axiomPos
    \UnaryInfC{$\Gamma, \Phi^+(\tau) \vdash \Phi^+(\tau)$}
  \end{prooftree}

  \begin{prooftree}
    \AxiomC{}
    \axiomNeg
    \UnaryInfC{$\Gamma, \Phi^-(\tau) \vdash \Phi^-(\tau)$}
  \end{prooftree}

  This seems trivial again:

  \begin{prooftree}
    \AxiomC{}
    \botRule
    \UnaryInfC{$\Gamma \vdash \Phi^+(\bot)$}
  \end{prooftree}

  This seems very questionable (but does not entail obviously wrong things with \textsc{Sub}$^-$):

  \begin{prooftree}
    \AxiomC{}
    \topRule
    \UnaryInfC{$\Gamma \vdash \Phi^-(\top)$}
  \end{prooftree}

  Probably should not be a rule:
  \begin{prooftree}
    \alwaysNoLine
    \AxiomC{\texttt{instance }$\Phi(\tau)$}
    \alwaysSingleLine
    \instanceDeclRule
    \UnaryInfC{$\Phi(\tau) \vdash$}
  \end{prooftree}

\section{Dictionary Passing}

One typical way of implementing type classes is using \emph{dicitonary passing style}.
We use an isomorphism between type classes and records:
E.g. the type class \mintinline{Haskell}{Eq} defined as

\begin{minted}{Haskell}
  class Eq a where
    eq :: a -> a -> Bool
    neq :: a -> a -> Bool
\end{minted}

can be translated to a record type that preserves the structure of the class:

\begin{minted}{Haskell}
  data DictEq a =
    DictEq { eq :: a -> a -> Bool,
             neq :: a -> a -> Bool }
\end{minted}

Instances as witnesses of type classes can be translated accordingly to values of dictionaries.
E.g.

\begin{minted}{Haskell}
  instance Eq Int where
    eq = intEq
    neq = not . intEq  
\end{minted}

can be translated to a value of type \mintinline{Haskell}{DictEq Int}:

\begin{minted}{Haskell}
  intEqDict = DictEq { eq = intEq,
                       neq = not . intEq }
\end{minted}

Here, the instances of a type class are carried in a dictionary that has to be passed as an additional argument to method calls.
For example the term

\begin{minted}{Haskell}
  show 5
\end{minted}

would be compiled to

\begin{minted}{Haskell}
  show showIntDict 5
\end{minted}

where \mintinline{Haskell}{showIntDict} is a dictionary that provides the relevant defintion of \mintinline{Haskell}{show :: Int -> String} for the instance of \mintinline{Haskell}{Show Int}.
This allows us to "compile away" the overhead that type classes introduce to the surface language because type inference can fill in the correct dictionary that is ought to be used.

Generic constrained functions like

\begin{minted}{Haskell}
  emphasize :: (Show a) => a -> String
  emphasize x = show x ++ "!"
\end{minted}

would simply pass around the dictionary and be compiled to something like:

\begin{minted}{Haskell}
  emphasize :: ShowDict a -> a -> String
  emphasize dict x = show dict x ++ "!"
\end{minted}

\cite{kiselyov}

There is a drawback however, in the presence of subtyping it may not always be clear which dictionary is going to be needed for instance resolution.
Consider the term:

\begin{minted}{text}
  show (if b then 42 :: Int else "Hello" :: String)
\end{minted}

The inferred type of this expression should be \mintinline{text}{Int \/ String}.
What we need here are essentially two dictionaries: One for \mintinline{text}{Int} and one for \mintinline{text}{String} because it is undecidable at compile time which dictionary is going to be used at runtime.
% Would it not be possible to just construct a new dictionary consisting of both variants?

\section{Intensional type analysis}

Instead of passing around dictionaries, we can also resolve the relevant instance at runtime dispatching on the term's type.
This requires our language to tag term with some representation of their type at runtime.
In the before mentioned case, the definition of \mintinline{Haskell}{show} could look something like this:

\begin{minted}{Haskell}
  show t x = case t of
    Bool -> boolShow x
    Int -> intShow x
\end{minted}

In the context of subtyping we would not require type equality but for \mintinline{Haskell}{t} to be a subtype of some type for which an instance is defined.
This also renders intensional type analysis more difficult:
We can not simply match on a type (or its encoded representation \cite{weirich2000}) because we have to essentially solve the problem of subtyping between the type at hand and (at worst case) for each type for which an instance declaration is in scope.
So, intensional type analysis may introduce a dramatic overhead in the presence of subtyping.

\section{Type class coherence in the context of subtyping}
% Main thesis for class coherence with subtyping
  Given \texttt{instance C a} and $sub \sub a$ and $a \sub sup$, we can neither have \texttt{instance C sub}, nor \texttt{instance C sup}.

  Consider we have \texttt{Nat \sub Int}.
  We can implement Monoid instances for both types. For natural numbers we choose multiplication as operator and accordingly 1 as neutral element.
  For integers on the other hand, we might prefer to choose addition as operator and 0 as neutral element, so we can expand to monoid to a group.

  Building programs on top of these instances is going to get tedious as it will often occur that the more specific \texttt{Nat} type will be inferred,
  even if only want to deal with integers.
  Using the append operator exposed by the Monoid typeclass, therefore may lead to unexpected behavior.
  % Note for a good example, we need a good notion of type inference for this case, which is currently not implemented.

  In the simple arithmetic expression $(a \oplus b) \oplus c$ $\oplus$ can have two different meanings based on the inferred types of $a,b$ and $c$.
  Since type inferrence with subtyping is generally not quite obvious it may seem 

  Could we just use the most specific instance? This might have unexpected results.
  E.g. if we have \texttt{NonEmptyList \sub List}, we may not know during compilation whether \texttt{NonEmptyList} or \texttt{List} is being picked.
  ~Generally to infer the most specific type seems very hard. In this example filtering a \texttt{NonEmptyList} may or may not return an empty list and we may just have to assume that it is possibly empty.
  This may lead to hard to track behaviour when using overlapping instances.

  A simple example for undecidable most specific instances can be better given with record types.
  If we need to resolve an instance for \texttt{C {x : Int}} and we already have instances for \texttt{C {x : Int, y : Int}} and \texttt{C {x : Int, z : Int}} neither instance is more specific than the other.


  We should always check in an instance declaration whether this constraint globally holds. \\
  To guarantee modularity we also have to check this for module imports (possibly hiding instances).

\section{Joining Type Classes}
% also treated in the next section

The rules \textsc{Join}$^+$ and \textsc{Meet}$^-$ as mentioned before cannot be derived from the subtyping rules alone.
It may seem intuitive that given $Show \; \tau$ and $Show \; \sigma$ we also have $Show \; \tau \; \join \; \sigma$.
Dually we should also be able to resolve $Read \; \tau \; \meet \; \sigma$ from $Read \; \tau$ and $Read \; \sigma$.

However these rules cannot be implemented generally.
Consider type classes with methods in which the bound type variable occurs more than once (unlike in $Show$ and $Read$).
As an example where this rule cannot be implemented, let us look at the $Eq$ type class:

\begin{gather}
\nonumber {\bf class} \; Eq \; a \; where\\
\nonumber  eq : a \to a \to Bool
\end{gather}

Given instances $Eq \; Nat$ and $Eq \; Bool$, we may expect to have $Eq \; Nat \; \join \; Bool$ but e.g. the term $eq \; 5 \; True$ cannot be trivially implemented based on known implementations for $eq$.
Therefore, these non-derivable rules cannot be used for type class resolution.

\section{Implementation}

There is a problem when we want to implement the union type.

Consider again the \texttt{Show} typeclass. It is intuitive to see how we can construct the \texttt{show} method for the union of two types, given that it is defined for both respecetively.
However, looking at the \texttt{Eq} typeclass, we can not generally deduce an instance of the join of two types.
If we solely know how to compare terms of type $\tau$ with each other and how to compare terms of type $\sigma$ with each other,
we do not know how to compare a term of type $\tau$ with a term of type $\sigma$, even though the derived instance tells we should be able to do so.

We might be able to just return \texttt{False} as a default value in such cases but even default values can be ambiguous.
Consider now the \texttt{Ord} type class. Given \texttt{Ord a} and \texttt{Ord b} we may say that in \texttt{Ord a $\join$ b} every $a$ is ordered before $b$.
But given the commutativity of $\join$, this would violate type class coherence because $a \join b = b \join a$ but \texttt{Ord a $\join$ b} $\neq$ \texttt{Ord b $\join$ a}.

\begin{listing}
  show$_{a\join b}$ x := if typeOf x == a then show$_a$ x else show$_b$ x
\end{listing}


\subsection{Multi Parameter Type Classes}

The concrete implementation may impose further restrictions on instance resolution.

Our language differentiattes covariant and contravariant type classes.
This distinction is made for the type variable declared in the class declaration.

In a covariant type class, type variables may only occur on covariant positions in the class methods signatures.
A simple example for a covariant type class is the \mintinline{Haskell}{Show} class:

\begin{minted}{Haskell}
  class Show +a where
    show :: a -> String
\end{minted}

Dually in a contravariant type class, type variables may only occur on contravariant positions in the class methods signatures.
A simple example for a contravariant type class is the \mintinline{Haskell}{Read} class:

\begin{minted}{Haskell}
  class Read -a where
    read :: Read -> a
\end{minted}

This distinction imposes a problem when we want to implement type classes in which the type variable may occur both in a covariant and contravariant position.

\begin{minted}{Haskell}
  class Semigroup a where
    mappend :: a -> a -> a
\end{minted}

One way to solve this problem is by distinguishing covariant and contravariant type variables.
We can do so by introducing multi parameter type classes:

\begin{minted}{Haskell}
  class Semigroup +a -b where
    mappend :: a -> a -> b
\end{minted}

Instead of defining an instance for \mintinline{Haskell}{Semigroup Nat}, we would then have to define an instance for \mintinline{Haskell}{Semigroup Nat Nat}.
The latter seems to be less intuitive because semigroups are not a relation between types but a property for just one type (the operator has to map two elements from one set into the same set).
Since such cases may occur in many other classes (e.g. Num, Monad) it may be helpful to define syntactic sugar for type classes with mixed variance.
Then, the less intuitive implementation as multi parameter type classes could be hidden on the surface syntax.

  Discuss instance chains:
  We can relax this constraint by defining an explicit order in which instances should be picked/resolved.
  \cite{morris2010instance}