\chapter{Qualified Types}
\label{ch:qualified-types}

\section{Theory of Predicates}
\label{sec:theory-predicates}

To reason about ad-hoc polymorhism we talk about \emph{qualified types}, i.e. types that satisfy some predicate.

\begin{definition} Predicates\\
  Given a universe of types $\Unit$, a \emph{predicate over types} $\Phi$ is an element of $\mathcal{P}(\Unit)$.
\end{definition}

We are only interested in predicates that are preserved over the subtyping lattice.
I.e. predicates that depend only on the terms of a type.
That means only predicates that are \emph{monotonous} are considered while other predicates such as \emph{"has exactly two values"} are disregarded.
We further differentiate between \emph{covariant}, \emph{contravariant} and \emph{invariant} predicates over types.

Let $\Gamma$ be the context of facts, i.e. known types that satisfy specific predicates.

\subsection{Covariant Predicates}
\label{sec:covariant-predicates}

\begin{definition}
  A \emph{covariant type class predicate} $\Phi^+$ is a predicate preserved by the subtyping relation, i.e. it adheres to the following rule:
\end{definition}

% The monotonicity of $\Phi^+$ motivates the following rule preserving the predicate for subtypes.
% From the definition of covariant predicates it follows that $\phi$ holds for every term of $\sigma$ and because every witness of $\tau$ is also a witness of $\sigma$ the characteristic property $\phi$ holds for all witnesses of $\tau$.

% ^< statt ^+

\begin{prooftree}
  \AxiomC{$\ctx \Phi^+(\sigma)$}
  \AxiomC{$\tau \sub \sigma$}
  \alwaysSingleLine
  \RightLabel{\textsc{CoV}}
  \BinaryInfC{$\ctx \Phi^+(\tau)$}
\end{prooftree}

With \textsc{CoV} and the subtyping rules in fig. \ref{fig:subtyping} we can derive several useful rules:

\begin{figure}[ht]
  \begin{center}
    \AxiomC{$\ctx \Phi^+(\top)$}
    \AxiomC{}
    \RightLabel{\textsc{Top}}
    \UnaryInfC{$\tau \sub \top$}
    \alwaysSingleLine
    \RightLabel{\textsc{CoV}}
    \BinaryInfC{$\ctx \Phi^+(\tau)$}
    \DisplayProof
    \deriveRule
    \AxiomC{$\ctx \Phi^+(\top)$}
    \alwaysSingleLine
    \RightLabel{\textsc{Top}$^+$}
    \UnaryInfC{$\ctx \Phi^+(\tau)$}
    \DisplayProof
  \end{center}

  \begin{center}
    \AxiomC{$\ctx \Phi^+(\tau)$}
    \AxiomC{}
    \RightLabel{\textsc{Bot}}
    \UnaryInfC{$\bot \sub \tau$}
    \alwaysSingleLine
    \RightLabel{\textsc{CoV}}
    \BinaryInfC{$\ctx \Phi^+(\bot)$}
    \DisplayProof
    \deriveRule
    \AxiomC{$\ctx \Phi^+(\tau)$}
    \alwaysSingleLine
    \RightLabel{\textsc{Bot}$^+$}
    \UnaryInfC{$\ctx \Phi^+(\bot)$}
    \DisplayProof
  \end{center}

  \begin{center}
    \AxiomC{$\ctx \Phi^+(\tau)$}
    \AxiomC{}
    \RightLabel{\textsc{Refl}}
    \UnaryInfC{$\tau \sub \tau$}
    \RightLabel{\textsc{MeetI}$_1$}
    \UnaryInfC{$\tau \meet \sigma \sub \tau$}
    \alwaysSingleLine
    \RightLabel{\textsc{CoV}}
    \BinaryInfC{$\ctx \Phi^+(\tau \meet \sigma)$}
    \DisplayProof
    \deriveRule
    \AxiomC{$\ctx \Phi^+(\tau)$}
    \alwaysSingleLine
    \RightLabel{\textsc{Meet}$_1^+$}
    \UnaryInfC{$\ctx \Phi^+(\tau \meet \sigma)$}
    \DisplayProof
  \end{center}

  \begin{center}
    \AxiomC{$\ctx \Phi^+(\tau)$}
    \AxiomC{}
    \RightLabel{\textsc{Refl}}
    \UnaryInfC{$\tau \sub \tau$}
    \RightLabel{\textsc{MeetI}$_2$}
    \UnaryInfC{$\sigma \meet \tau \sub \tau$}
    \alwaysSingleLine
    \RightLabel{\textsc{CoV}}
    \BinaryInfC{$\ctx \Phi^+(\sigma \meet \tau)$}
    \DisplayProof
    \deriveRule
    \AxiomC{$\ctx \Phi^+(\tau)$}
    \alwaysSingleLine
    \RightLabel{\textsc{Meet}$_2^+$}
    \UnaryInfC{$\ctx \Phi^+(\sigma \meet \tau)$}
    \DisplayProof
  \end{center}

  \begin{center}
    \AxiomC{$\ctx \Phi^+(\Int)$}
    \AxiomC{}
    \RightLabel{\textsc{NatPrim}}
    \UnaryInfC{$\Nat \sub \Int$}
    \alwaysSingleLine
    \RightLabel{\textsc{CoV}}
    \BinaryInfC{$\ctx \Phi^+(\Nat)$}
    \DisplayProof
    \deriveRule
    \AxiomC{$\ctx \Phi^+(\Int)$}
    \alwaysSingleLine
    \RightLabel{\textsc{NatPrim}$^+$}
    \UnaryInfC{$\ctx \Phi^+(\Nat)$}
    \DisplayProof
  \end{center}

  \caption{Derived rules for covariant predicates}
  \label{fig:derived-covariant-rules}
\end{figure}

A typical example for covariant predicates is $\Showable$: all types that are showable, which generally rules out function types.
The \textsc{CoV} rule seems intuitive for this:
If $e : \tau$ is a showable term and $\tau \sub \sigma$, then $e : \sigma$ can be shown in the same way.

\subsection{Contravariant Predicates}
\label{sec:contravariant-predicates}

\begin{definition}
  A \emph{contravariant type class predicate} $\Phi^-$ is a predicate preserved by the supertyping or flipped subtyping relation, i.e. it adheres to the following rule:
\end{definition}

\begin{prooftree}
  \alwaysNoLine
  \AxiomC{$\ctx \Phi^-(\sigma)$}
  \AxiomC{$\sigma \sub \tau$}
  \alwaysSingleLine
  \RightLabel{\textsc{ContraV}}
  \BinaryInfC{$\ctx \Phi^-(\tau)$}
\end{prooftree}

The rules for contravariant predicates are dual to those for covariant predicates.
The monotonicity of $\Phi^-$ motivates the following rule preserving the predicate for supertypes:
From the definition of contravariant predicates it follows that $\phi$ holds for some term of $\sigma$ and because every witness of $\sigma$ is also a witness of $\tau$ there is at least one witness of $\tau$ for which the characteristic property $\phi$ holds.

With \textsc{ContraV} and the subtyping rules in fig. \ref{fig:subtyping} we can again derive several useful rules:

\begin{figure}[ht]
  \begin{center}
    \AxiomC{$\ctx \Phi^-(\tau)$}
    \AxiomC{}
    \RightLabel{\textsc{Top}}
    \UnaryInfC{$\tau \sub \top$}
    \alwaysSingleLine
    \RightLabel{\textsc{ContraV}}
    \BinaryInfC{$\ctx \Phi^-(\top)$}
    \DisplayProof
    \deriveRule
    \AxiomC{$\ctx \Phi^-(\tau)$}
    \alwaysSingleLine
    \RightLabel{\textsc{Top}$^-$}
    \UnaryInfC{$\ctx \Phi^-(\top)$}
    \DisplayProof
  \end{center}

  \begin{center}
    \AxiomC{$\ctx \Phi^-(\bot)$}
    \AxiomC{}
    \RightLabel{\textsc{Bot}}
    \UnaryInfC{$\bot \sub \tau$}
    \alwaysSingleLine
    \RightLabel{\textsc{ContraV}}
    \BinaryInfC{$\ctx \Phi^-(\tau)$}
    \DisplayProof
    \deriveRule
    \AxiomC{$\ctx \Phi^-(\bot)$}
    \alwaysSingleLine
    \RightLabel{\textsc{Bot}$^-$}
    \UnaryInfC{$\ctx \Phi^-(\tau)$}
    \DisplayProof
  \end{center}

  \begin{center}
    \AxiomC{$\ctx \Phi^-(\tau)$}
    \AxiomC{}
    \RightLabel{\textsc{Refl}}
    \UnaryInfC{$\tau \sub \tau$}
    \RightLabel{\textsc{JoinI}$_1$}
    \UnaryInfC{$\tau \sub \tau \join \sigma$}
    \alwaysSingleLine
    \RightLabel{\textsc{ContraV}}
    \BinaryInfC{$\ctx \Phi^-(\tau \join \sigma)$}
    \DisplayProof
    \deriveRule
    \AxiomC{$\ctx \Phi^-(\tau)$}
    \alwaysSingleLine
    \RightLabel{\textsc{Join}$_1^-$}
    \UnaryInfC{$\ctx \Phi^-(\tau \join \sigma)$}
    \DisplayProof
  \end{center}

  \begin{center}
    \AxiomC{$\ctx \Phi^-(\tau)$}
    \AxiomC{}
    \RightLabel{\textsc{Refl}}
    \UnaryInfC{$\tau \sub \tau$}
    \RightLabel{\textsc{JoinI}$_2$}
    \UnaryInfC{$\tau \sub \sigma \join \tau$}
    \alwaysSingleLine
    \RightLabel{\textsc{ContraV}}
    \BinaryInfC{$\ctx \Phi^-(\sigma \join \tau)$}
    \DisplayProof
    \deriveRule
    \AxiomC{$\ctx \Phi^-(\tau)$}
    \alwaysSingleLine
    \RightLabel{\textsc{Join}$_2^-$}
    \UnaryInfC{$\ctx \Phi^-(\sigma \join \tau)$}
    \DisplayProof
  \end{center}

  \begin{center}
    \AxiomC{$\ctx \Phi^-(\Nat)$}
    \AxiomC{}
    \RightLabel{\textsc{NatPrim}}
    \UnaryInfC{$\Nat \sub \Int$}
    \alwaysSingleLine
    \RightLabel{\textsc{ContraV}}
    \BinaryInfC{$\ctx \Phi^-(\Int)$}
    \DisplayProof
    \deriveRule
    \AxiomC{$\ctx \Phi^-(\Nat)$}
    \alwaysSingleLine
    \RightLabel{\textsc{NatPrim}$^-$}
    \UnaryInfC{$\ctx \Phi^-(\Int)$}
    \DisplayProof
  \end{center}
  \caption{Derived rules for contravariant predicates}
  \label{fig:contravariant-derived-rules}
\end{figure}

A typical example for covariant predicates is $\Defaultable$: all types for which some default value can be predefined, which also generally rules out function types and empty types.
The \textsc{ContraV} again rule seems intuitive for this:
% fix:
If $e : \tau$ is a default value for $\tau$ and $\sigma \sub \tau$, then $e : \sigma$ can be used as a default value for $\sigma$ as well.


% \begin{center}
%   \alwaysNoLine
%   \AxiomC{$\ctx \Phi^-(\tau \meet \sigma)$}
%   \alwaysSingleLine
%   \RightLabel{\textsc{Meet}$_1^-$}
%   \UnaryInfC{$\ctx \Phi^-(\tau)$}
%   \DisplayProof
%   {\hskip.2in}
%   \alwaysNoLine
%   \AxiomC{$\ctx \Phi^-(\tau \meet \sigma)$}
%   \alwaysSingleLine
%   \RightLabel{\textsc{Meet}$_2^-$}
%   \UnaryInfC{$\ctx \Phi^-(\sigma)$}
%   \DisplayProof
% \end{center}

We omit the $^+$ and $^-$ superscripts if the variance of predicates does not matter.
Using this notation we can simplify axioms and the rule for constraints.
The rule for axioms is trivial: We can resolve known facts directly from the context.

\begin{prooftree}
  \AxiomC{}
  \RightLabel{\textsc{Axiom}}
  \UnaryInfC{$\Gamma, \Phi(\tau) \vdash \Phi(\tau)$}
\end{prooftree}

\subsection{Invariant Predicates}
\label{sec:invariant-predicates}

\begin{definition}
  An \emph{invariant type class predicate} $\Phi^-$ is a predicate preserved by the subtyping \emph{and} flipped subtyping relation, i.e. it adheres to the following rule:
\end{definition}

\begin{prooftree}
  \alwaysNoLine
  \AxiomC{$\ctx \Phi(\sigma)$}
  \AxiomC{$\sigma \sub \tau$}
  \AxiomC{$\tau \sub \sigma$}
  \alwaysSingleLine
  \RightLabel{\textsc{InV}}
  \TrinaryInfC{$\ctx \Phi(\tau)$}
\end{prooftree}

Invariant type class predicates can essentially only be derived from type equalitites, i.e. where a type is both a sub- and supertype of another.
Hence, there are no interesting derivable rules for them.

A typical example for invariant predicates is $\Monoid$, satisfied by any type for which we can define a monoid, i.e. there is a total function combining two values of the type to a new one and a neutral element corresponding to this operation.

\subsection{Predicate Implications}
\label{sec:predicate-implications}

Predicates may be constrained, i.e. they depend on other predicates.
$\Phi(\tau) \Rightarrow \Psi(\tau)$ means $\Psi$ is constrained by $\Phi$.
Thus, if $\Psi(\tau)$ is satisfied, then the constraint $\Phi(\tau)$ is satisfied as well.
Note that this corresponds to implications even though the arrow is flipped as it is oriented towards constraints.

\begin{prooftree}
  \AxiomC{$\ctx \Psi(\tau)$}
  \AxiomC{$\ctx \Phi(\tau) \Rightarrow \Psi(\tau)$}
  \RightLabel{\textsc{Constr}}
  \BinaryInfC{$\Gamma \vdash \Phi(\tau)$}
\end{prooftree}

\subsection{Examples}

Consider the predicates $\Showable$ and $\Defaultable$.
A type $\tau$ satsifies the covariant predicate $\Showable$ if a total function of $\tau \to String$ can be defined.
Dually, a type $\tau$ satsifies the contravariant predicate $\Defaultable$ if a value of type $\tau$ can be defined.

Let context $\Gamma := \{ \Showable(\Int), \Defaultable(\Nat),  \Monoid(\Nat) \}$.
We obtain the following derivations for $\Showable(\Singleton{1} \meet \Nat)$:
We can interpret the derivation in fig. \ref{fig:example-showable} as a proof for \emph{Given a way to show an integer, we can also show anything that is both a natural number and of the singleton type $\Singleton{1}$} and

\begin{figure}[ht]
  \begin{prooftree}
    \AxiomC{}
    \RightLabel{\textsc{Axiom}}
    \UnaryInfC{$\ctx \Showable(\Int)$}
    \RightLabel{\textsc{Prim}$^+$}
    \UnaryInfC{$\ctx \Showable(\Nat)$}
    \RightLabel{\textsc{Meet}$^+_2$}
    \UnaryInfC{$\ctx \Showable(\Singleton{1} \meet \Nat)$}
  \end{prooftree}
  \caption{Derivation for $\ctx \Showable(\Singleton{1} \meet \Nat)$}
  \label{fig:example-showable}
\end{figure}

Using $\Gamma$ from above, we can derive $\Showable(\Singleton{1} \meet \Nat)$ (fig. \ref{fig:example-defaultable}).
In natural language this proves that \emph{given a default value for $\Nat$, we also obtain a default value for the union of $\Int$ and $\Bool$}


\begin{figure}[ht]
  \begin{prooftree}
    \AxiomC{}
    \RightLabel{\textsc{Axiom}}
    \UnaryInfC{$\ctx \Defaultable(\Nat)$}
    \RightLabel{\textsc{Prim}$^-$}
    \UnaryInfC{$\ctx \Defaultable(\Int)$}
    \alwaysSingleLine
    \RightLabel{\textsc{Join}$^-_1$}
    \UnaryInfC{$\ctx \Defaultable(\Int \join \Bool)$}
  \end{prooftree}
  \caption{Derivation for $\ctx \Defaultable(\Int \join \Bool)$}
  \label{fig:example-defaultable}
\end{figure}

Finally, again using $\Gamma$ defined above, we can prove judgements for invariant predicates for non syntactically equal types.
The derivation in fig. \ref{fig:example-monoid} combines the \textsc{InV}-rule with a proof that $\Nat$ and $\Nat \join \Singleton{1}$ are equivalent to prove that we can derive $\Monoid(\Nat \join \Singleton{1})$ from $\Monoid(\Nat)$.

\begin{figure}[ht]
  \begin{prooftree}
    \AxiomC{}
    \RightLabel{\textsc{Axiom}}
    \UnaryInfC{$\ctx \Monoid(\Nat)$}
    \AxiomC{}
    \RightLabel{\textsc{Refl}}
    \UnaryInfC{$\Nat \sub \Nat$}
    \RightLabel{\textsc{JoinI}$_1$}
    \UnaryInfC{$\Nat \sub \Nat \join \Singleton{1}$}
    \AxiomC{}
    \RightLabel{\textsc{Refl}}
    \UnaryInfC{$\Nat \sub \Nat$}
    \AxiomC{}
    \RightLabel{\textsc{SingletonPrim}$_1$}
    \UnaryInfC{$\Singleton{1} \sub \Nat$}
    \RightLabel{\textsc{JoinI}}
    \BinaryInfC{$\Nat \join \Singleton{1} \sub \Nat$}
    \RightLabel{\textsc{Axiom}}
    \alwaysSingleLine
    \RightLabel{\textsc{InV}}
    \TrinaryInfC{$\ctx \Monoid(\Nat \join \Singleton{1})$}
  \end{prooftree}
  \caption{Derivation for $\ctx \Monoid(\Nat \join \Singleton{1})$}
  \label{fig:example-monoid}
\end{figure}

\section{Witnesses}
\label{sec:witnesses}

By annotating applications of predicates with specific witnesses we obtain a calculus
that is not only able to prove that a type satisfies a predicate but also constructs a witness for such a proof.

Constructing witnesses directly corresponds to type class resolution if we interpret type classes as predicates on types.
Multiple witnesses can be derived for the same judgement but in order to preserve type class coherence they have to satsify some form of equivalence.
We again differentiate co-, contra-  and invariant type classes in order to transport type classes over the subtyping relation.

\begin{figure}[ht]
  % refl
  \begin{prooftree}
    \AxiomC{}
    \RightLabel{\textsc{Refl}}
    \UnaryInfC{$\refl_\tau : \tau \sub \tau$}
  \end{prooftree}

  % trans
  \begin{prooftree}
    \AxiomC{$f : \tau \sub \sigma$}
    \AxiomC{$g : \sigma \sub \rho$}
    \RightLabel{\textsc{Trans}}
    \BinaryInfC{$f \comp g : \tau \sub \rho$}
  \end{prooftree}

  % top/bot
  \begin{center}
    \AxiomC{}
    \RightLabel{\textsc{Top}}
    \UnaryInfC{$\topW_\tau : \tau \sub \top$}
    \DisplayProof
    {\hskip.2in}
    \AxiomC{}
    \RightLabel{\textsc{Bot}}
    \UnaryInfC{$\botW_\tau : \bot \sub \tau$}
    \DisplayProof
  \end{center}

  % join intro
  \begin{center}
    \AxiomC{$f : \tau \sub \sigma$}
    \RightLabel{\textsc{JoinI}$_1$}
    \UnaryInfC{$\inW{1}(f) : \tau \sub \sigma \join \rho$}
    \DisplayProof
    {\hskip.2in}
    \AxiomC{$f: \tau \sub \sigma$}
    \RightLabel{\textsc{JoinI}$_2$}
    \UnaryInfC{$\inW{2}(f) : \tau \sub \rho \join \sigma$}
    \DisplayProof
  \end{center}

  \begin{prooftree}
    \AxiomC{$f : \tau \sub \rho$}
    \AxiomC{$g : \sigma \sub \rho$}
    \RightLabel{\textsc{JoinI}}
    \BinaryInfC{$\joinW(f,g) : \tau \join \sigma \sub \rho$}
  \end{prooftree}

  % meet intro
  \begin{center}
    \AxiomC{$f : \tau \sub \rho$}
    \RightLabel{\textsc{MeetI}$_1$}
    \UnaryInfC{$\proj{1}(f) : \tau \meet \sigma \sub \rho$}
    \DisplayProof
    {\hskip.2in}
    \AxiomC{$f : \sigma \sub \rho$}
    \RightLabel{\textsc{MeetI}$_2$}
    \UnaryInfC{$\proj{2}(f) : \tau \meet \sigma \sub \rho$}
    \DisplayProof
  \end{center}

  \begin{prooftree}
    \AxiomC{$f : \tau \sub \sigma$}
    \AxiomC{$g : \tau \sub \rho$}
    \RightLabel{\textsc{MeetI}}
    \BinaryInfC{$\meetW(f,g) : \tau \sub \sigma \meet \rho$}
  \end{prooftree}

  \begin{prooftree}
    \AxiomC{}
    \RightLabel{\textsc{NatPrim}}
    \UnaryInfC{$\natPrim : \Nat \sub \Int$}
  \end{prooftree}

  \begin{prooftree}
    \AxiomC{$f : \tau' \sub \tau$}
    \AxiomC{$g : \sigma \sub \sigma'$}
    \RightLabel{\textsc{Func}}
    \BinaryInfC{$\funcW(f,g) : \tau \to \sigma \sub \tau' \to \sigma'$}
  \end{prooftree}

  % recursive types
  \begin{center}
    \AxiomC{}
    \RightLabel{\textsc{Rec}$_1$}
    \UnaryInfC{$\unfoldR : \mu\rho.\tau \sub \tau [\mu\rho.\tau\ / \rho]$}
    \DisplayProof
    {\hskip.2in}
    \AxiomC{}
    \RightLabel{\textsc{Rec}$_2$}
    \UnaryInfC{$\unfoldL : \tau[\mu\rho.\tau / \rho] \sub \mu\rho.\tau$}
    \DisplayProof
  \end{center}
  \caption{Rules for subtyping witnesses}
  \label{fig:subtyping-witnesses}
\end{figure}

We use mappings $triv, in_{1/2}, proj_{1/2}$ to construct witnesses from given witnesses.

\begin{figure}[ht]
  \[
    \begin{tikzcd}
      & \tau \meet \sigma \arrow[lddd, "proj_1"'] \arrow[rddd, "proj_2"] & \\
      & & \\
      & & \\
      \tau & & \sigma
    \end{tikzcd}
  \]

  \[
    \begin{tikzcd}
      \tau \arrow[rddd, "in_1"'] & & \sigma \arrow[lddd, "in_2"] \\
      & & \\
      & & \\
      & \tau \join \sigma &
    \end{tikzcd}
  \]
  \caption{Witnesses for union \& intersection types}
  \label{fig:cd-proj/in}
\end{figure}

$triv$ is the trivial mapping corresponding to the $\top$ and $\bot$ rules.
$in_{1/2}$ correspond to the construction (injection) of an union type from either the first type $\tau$ or the second type $\sigma$ of the union $\tau \join \sigma$.
$proj_{1/2}$ correspond to the projection from an intersection type $\tau \meet \sigma$ to one of its constituent types $\tau$ or $\sigma$. We can interpret these morphisms as the supertype relation.

If there exists some instance declaration of type class $\Psi$ for a type $\tau$, we can directly resolve $\Psi(\tau)$.

\begin{prooftree}
  \AxiomC{$w : \instance{\Phi}{\tau}$}
  \RightLabel{\textsc{Decl}}
  \UnaryInfC{$i_\tau(w) : \Phi(\tau)$}
\end{prooftree}

Given that $\Phi(\tau) \Rightarrow \Psi(\tau)$ we can use that evidence $s$ to construct $\Phi(\tau)$ by applying it to the witness $w$ of $\Psi(\tau)$.

\begin{prooftree}
  \AxiomC{$w : \Psi(\tau)$}
  \AxiomC{$s : \Phi(\tau) \Rightarrow \Psi(\tau)$}
  \RightLabel{\textsc{SuperC}}
  \BinaryInfC{$s(w) : \Phi(\tau)$}
\end{prooftree}

We give witness derivation rules corresponding to \textsc{CoV}, \textsc{ContraV} and \textsc{InV}.
In order to construct a witness for a covariant predicate judgement, we need evidence for the judgement about a supertype and evidence that the type is in fact a supertype.

\begin{prooftree}
  \alwaysNoLine
  \AxiomC{$w : \Phi^+(\sigma)$}
  \AxiomC{$m : \tau \sub \sigma$}
  \alwaysSingleLine
  \RightLabel{\textsc{CoV}}
  \BinaryInfC{$\cov(w,m) : \Phi^+(\tau)$}
\end{prooftree}

In order to construct a witness for a contravariant predicate judgement, we need evidence for the judgement about a subtype and evidence that the type is in fact a subtype.

\begin{prooftree}
  \alwaysNoLine
  \AxiomC{$w : \Phi^-(\sigma)$}
  \AxiomC{$m : \sigma \sub \tau$}
  \alwaysSingleLine
  \RightLabel{\textsc{ContraV}}
  \BinaryInfC{$\contrav(w,m) : \Phi^-(\tau)$}
\end{prooftree}

Finally, in order to construct a witness for an invariant predicate judgement, we need evidence for the judgement about an equivalent type and evidence that the type is in fact equivalent, i.e. both a sub- and a supertype.

\begin{prooftree}
  \AxiomC{$w : \Phi(\sigma)$}
  \AxiomC{$m : \sigma \sub \tau$}
  \AxiomC{$n : \tau \sub \sigma$}
  \RightLabel{\textsc{InV}}
  \TrinaryInfC{$\inv(w,m,n) : \Phi(\tau)$}
\end{prooftree}

% macros
\begin{figure}[ht]
  \begin{center}
    \AxiomC{$w : \Phi^+(\top)$}
    \AxiomC{}
    \RightLabel{\textsc{Top}}
    \UnaryInfC{$\topW_\tau : \tau \sub \top$}
    \alwaysSingleLine
    \RightLabel{\textsc{CoV}}
    \BinaryInfC{$cov(w,\topW_\tau) : \Phi^+(\tau)$}
    \DisplayProof
    \deriveRule
    \AxiomC{$w : \Phi^+(\top)$}
    \alwaysSingleLine
    \RightLabel{\textsc{Top}$^+$}
    \UnaryInfC{$\cov(w,\topW_\tau)\Phi^+(\tau)$}
    \DisplayProof
  \end{center}

  \begin{center}
    \AxiomC{$w : \Phi^+(\tau)$}
    \AxiomC{}
    \RightLabel{\textsc{Bot}}
    \UnaryInfC{$\botW_\tau : \bot \sub \tau$}
    \alwaysSingleLine
    \RightLabel{\textsc{CoV}}
    \BinaryInfC{$\cov(w,\botW_\tau) : \Phi^+(\bot)$}
    \DisplayProof
    \deriveRule
    \AxiomC{$w : \Phi^+(\tau)$}
    \alwaysSingleLine
    \RightLabel{\textsc{Bot}$^+$}
    \UnaryInfC{$\cov(w,\botW_\tau) : \Phi^+(\bot)$}
    \DisplayProof
  \end{center}

  \begin{center}
    \AxiomC{$w : \Phi^+(\tau)$}
    \AxiomC{}
    \RightLabel{\textsc{Refl}}
    \UnaryInfC{$\refl_\tau : \tau \sub \tau$}
    \RightLabel{\textsc{MeetI}$_1$}
    \UnaryInfC{$\proj{1}(\refl_\tau) : \tau \meet \sigma \sub \tau$}
    \alwaysSingleLine
    \RightLabel{\textsc{CoV}}
    \BinaryInfC{$\cov(w,\proj{1}(\refl_\tau) : \Phi^+(\tau \meet \sigma)$}
    \DisplayProof
    \deriveRule
    \AxiomC{$w : \Phi^+(\tau)$}
    \alwaysSingleLine
    \RightLabel{\textsc{Meet}$_1^+$}
    \UnaryInfC{$\cov(w,\proj{1}(\refl_\tau)) : \Phi^+(\tau \meet \sigma)$}
    \DisplayProof
  \end{center}

  \begin{center}
    \AxiomC{$w : \Phi^+(\tau)$}
    \AxiomC{}
    \RightLabel{\textsc{Refl}}
    \UnaryInfC{$\refl_\tau : \tau \sub \tau$}
    \RightLabel{\textsc{MeetI}$_2$}
    \UnaryInfC{$\proj{2}(\refl_\tau) : \sigma \meet \tau \sub \tau$}
    \alwaysSingleLine
    \RightLabel{\textsc{CoV}}
    \BinaryInfC{$\cov(w,\proj{2}(\refl_\tau)) : \Phi^+(\sigma \meet \tau)$}
    \DisplayProof
    \vspace*{0.1in}
    \deriveRule
    \AxiomC{$w : \Phi^+(\tau)$}
    \alwaysSingleLine
    \RightLabel{\textsc{Meet}$_2^+$}
    \UnaryInfC{$\cov(w,\proj{2}(\refl_\tau)) : \Phi^+(\sigma \meet \tau)$}
    \DisplayProof
  \end{center}

  \begin{center}
    \AxiomC{$w : \Phi^+(\Int)$}
    \AxiomC{}
    \RightLabel{\textsc{NatPrim}}
    \UnaryInfC{$\natPrim : \Nat \sub \Int$}
    \alwaysSingleLine
    \RightLabel{\textsc{CoV}}
    \BinaryInfC{$\cov(w,\natPrim) : \Phi^+(\Nat)$}
    \DisplayProof
    \deriveRule
    \AxiomC{$w : \Phi^+(\Int)$}
    \alwaysSingleLine
    \RightLabel{\textsc{NatPrim}$^+$}
    \UnaryInfC{$\cov(w,\natPrim) : \Phi^+(\Nat)$}
    \DisplayProof
  \end{center}

  \caption{Derivations for covariant witnesses}
  \label{fig:derived-covariant-witnesses}
\end{figure}


\begin{figure}[ht]
  \begin{center}
    \AxiomC{$w : \Phi^-(\tau)$}
    \AxiomC{}
    \RightLabel{\textsc{Top}}
    \UnaryInfC{$\topW_\tau :\tau \sub \top$}
    \alwaysSingleLine
    \RightLabel{\textsc{ContraV}}
    \BinaryInfC{$\contrav(w,\topW_\tau) : \Phi^-(\top)$}
    \DisplayProof
    \deriveRule
    \AxiomC{$w : \Phi^-(\tau)$}
    \alwaysSingleLine
    \RightLabel{\textsc{Top}$^-$}
    \UnaryInfC{$\contrav(w,\topW_\tau) : \Phi^-(\top)$}
    \DisplayProof
  \end{center}

  \begin{center}
    \AxiomC{$w : \Phi^-(\bot)$}
    \AxiomC{}
    \RightLabel{\textsc{Bot}}
    \UnaryInfC{$\botW_\tau : \bot \sub \tau$}
    \alwaysSingleLine
    \RightLabel{\textsc{ContraV}}
    \BinaryInfC{$\contrav(w,\botW_\tau) : \Phi^-(\tau)$}
    \DisplayProof
    \deriveRule
    \AxiomC{$w : \Phi^-(\bot)$}
    \alwaysSingleLine
    \RightLabel{\textsc{Bot}$^-$}
    \UnaryInfC{$\contrav(w,\botW_\tau) \Phi^-(\tau)$}
    \DisplayProof
  \end{center}

  \begin{center}
    \AxiomC{$w : \Phi^-(\tau)$}
    \AxiomC{}
    \RightLabel{\textsc{Refl}}
    \UnaryInfC{$\refl : \tau \sub \tau$}
    \RightLabel{\textsc{JoinI}$_1$}
    \UnaryInfC{$\inW{1}(\refl_\tau) : \tau \sub \tau \join \sigma$}
    \alwaysSingleLine
    \RightLabel{\textsc{ContraV}}
    \BinaryInfC{$\contrav(w,\inW{1}(\refl_\tau)) : \Phi^-(\tau \join \sigma)$}
    \DisplayProof
    \deriveRule
    \AxiomC{$w : \Phi^-(\tau)$}
    \alwaysSingleLine
    \RightLabel{\textsc{Join}$_1^-$}
    \UnaryInfC{$\contrav(w,\inW{1}(\refl_\tau)) : \Phi^-(\tau \join \sigma)$}
    \DisplayProof
  \end{center}

  \begin{center}
    \AxiomC{$w : \Phi^-(\tau)$}
    \AxiomC{}
    \RightLabel{\textsc{Refl}}
    \UnaryInfC{$\refl_\tau : \tau \sub \tau$}
    \RightLabel{\textsc{JoinI}$_2$}
    \UnaryInfC{$\inW{2}(\refl_\tau) : \tau \sub \sigma \join \tau$}
    \alwaysSingleLine
    \RightLabel{\textsc{ContraV}}
    \BinaryInfC{$\contrav(w,\inW{2}(\refl_\tau)) : \Phi^-(\sigma \join \tau)$}
    \DisplayProof
    \deriveRule
    \AxiomC{$w : \Phi^-(\tau)$}
    \alwaysSingleLine
    \RightLabel{\textsc{Join}$_2^-$}
    \UnaryInfC{$\contrav(w,\inW{2}(\refl_\tau)) : \Phi^-(\sigma \join \tau)$}
    \DisplayProof
  \end{center}

  \begin{center}
    \AxiomC{$w : \Phi^-(\Nat)$}
    \AxiomC{}
    \RightLabel{\textsc{NatPrim}}
    \UnaryInfC{$\natPrim : \Nat \sub \Int$}
    \alwaysSingleLine
    \RightLabel{\textsc{ContraV}}
    \BinaryInfC{$\contrav(w,\natPrim) : \Phi^-(\Int)$}
    \DisplayProof
    \deriveRule
    \AxiomC{$w : \Phi^-(\Nat)$}
    \alwaysSingleLine
    \RightLabel{\textsc{NatPrim}$^-$}
    \UnaryInfC{$\contrav(w,\natPrim) : \Phi^-(\Int)$}
    \DisplayProof
  \end{center}

  \caption{Derived rules for contravariant witnesses}
  \label{fig:contravariant-witnesses}
\end{figure}

% We can obtain witnesses from and to the initial and terminal types $\bot$ and $\top$ with trivial morphism corresponding to the \textsc{Bot} and \textsc{Top} subtyping rules.

% \begin{center}
%   \alwaysNoLine
%   \AxiomC{$w : \Phi^+(\top)$}
%   \alwaysSingleLine
%   \RightLabel{\textsc{Top}$^+$}
%   \UnaryInfC{$triv(w) : \Phi^+(\tau)$}
%   \DisplayProof
%   {\hskip.2in}
%   \alwaysNoLine
%   \AxiomC{$w : \Phi^+(\tau)$}
%   \alwaysSingleLine
%   \RightLabel{\textsc{Bot}$^+$}
%   \UnaryInfC{$triv(w) : \Phi^+(\bot)$}
%   \DisplayProof
% \end{center}

% \begin{center}
%   \alwaysNoLine
%   \AxiomC{$w : \Phi^-(\tau)$}
%   \alwaysSingleLine
%   \RightLabel{\textsc{Top}$^-$}
%   \UnaryInfC{$triv(w) : \Phi^-(\top)$}
%   \DisplayProof
%   {\hskip.2in}
%   \alwaysNoLine
%   \AxiomC{$w : \Phi^-(\bot)$}
%   \alwaysSingleLine
%   \RightLabel{\textsc{Bot}$^-$}
%   \UnaryInfC{$triv(w) : \Phi^-(\tau)$}
%   \DisplayProof
% \end{center}

% Interpreting $in_{1/2}$ and $proj_{1/2}$ as morphisms from a type to one of its supertypes the rules corresponding to the covariant \textsc{Join}$^+$ and \textsc{Meet}$^+$ rules are obvious.

% \begin{center}
%   \AxiomC{$in_1(w) : \Phi^+(\tau \join \sigma)$}
%   \RightLabel{\textsc{Join}$_1^+$}
%   \UnaryInfC{$w : \Phi^+(\tau)$}
%   \DisplayProof
%   {\hskip.2in}
%   \AxiomC{$in_2(w) : \Phi^+(\tau \join \sigma)$}
%   \RightLabel{\textsc{Join}$_2^+$}
%   \UnaryInfC{$w : \Phi^+(\sigma)$}
%   \DisplayProof
% \end{center}

% \begin{center}
%   \AxiomC{$proj_1(w) : \Phi^+(\tau)$}
%   \RightLabel{\textsc{Meet}$_1^+$}
%   \UnaryInfC{$w : \Phi^+(\tau \meet \sigma)$}
%   \DisplayProof
%   {\hskip.2in}
%   \AxiomC{$proj_2(w) : \Phi^+(\sigma)$}
%   \RightLabel{\textsc{Meet}$_2^+$}
%   \UnaryInfC{$w : \Phi^+(\tau \meet \sigma)$}
%   \DisplayProof
% \end{center}

% Analagously, with the interpretation of $in_{1/2}$ and $proj_{1/2}$  the rules corresponding to the contravariant \textsc{Join}$^-$ and \textsc{Meet}$^-$ rules are again obvious.

% \begin{center}
%   \AxiomC{$w : \Phi^-(\tau \meet \sigma)$}
%   \RightLabel{\textsc{Meet}$_1^-$}
%   \UnaryInfC{$proj_1(w) : \Phi^-(\tau)$}
%   \DisplayProof
%   {\hskip.2in}
%   \AxiomC{$w : \Phi^-(\tau \meet \sigma)$}
%   \RightLabel{\textsc{Meet}$_2^-$}
%   \UnaryInfC{$proj_2(w) : \Phi^+(\sigma)$}
%   \DisplayProof
% \end{center}

% \begin{center}
%   \AxiomC{$w : \Phi^-(\tau)$}
%   \RightLabel{\textsc{Join}$_1^-$}
%   \UnaryInfC{$in_1(w) : \Phi^-(\tau \join \sigma)$}
%   \DisplayProof
%   {\hskip.2in}
%   \AxiomC{$w : \Phi^-(\sigma)$}
%   \RightLabel{\textsc{Join}$_2^-$}
%   \UnaryInfC{$in_2(w) : \Phi^-(\tau \join \sigma)$}
%   \DisplayProof
% \end{center}

\subsection{Examples}

We present witness derivations for the examples in the previous section.
The context is replaced with an instance declaration which forms the leaf in the derivation.

\begin{figure}[ht]
  \begin{prooftree}
    \AxiomC{$w : \mathbf{instance} \; \Showable(\Int)$}
    \RightLabel{\textsc{Decl}}
    \UnaryInfC{$i_\Int(w) : \Showable(\Int)$}
    \AxiomC{}
    \RightLabel{\textsc{NatPrim}$^+$}
    \UnaryInfC{$\mathit{natPrim} : \Nat \sub \Int$}
    \RightLabel{\textsc{Meet}$^+_2$}
    \UnaryInfC{$\mathit{proj}_2(\mathit{natPrim}) : \Singleton{1} \meet \Nat \sub \Int$}
    \RightLabel{\textsc{CoV}}
    \BinaryInfC{$cov(i_\Int(w), \mathit{proj}_2(\mathit{natPrim})) : \Showable(\Singleton{1} \meet \Nat)$}
  \end{prooftree}
  \caption{Witness derivation for $cov(i_\Int(w), \mathit{proj}_2(\mathit{natPrim})) : \Showable(\Unit \meet \Nat)$}
  \label{fig:witness-example-showable}
\end{figure}

\begin{figure}[ht]
  \begin{prooftree}
    \AxiomC{$w : \mathbf{instance} \; \Defaultable(\Nat)$}
    \RightLabel{\textsc{Decl}}
    \UnaryInfC{$i_\Nat(w) : \Defaultable(\Nat)$}
    \AxiomC{}
    \RightLabel{\textsc{NatPrim}$^+$}
    \UnaryInfC{$\mathit{natPrim} : \Nat \sub \Int$}
    \RightLabel{\textsc{Meet}$^+_2$}
    \UnaryInfC{$\mathit{in}_1(\mathit{natPrim}) : \Nat \sub \Bool \join \Int$}
    \RightLabel{\textsc{CoV}}
    \BinaryInfC{$contrav(i_\Nat(w), \mathit{in}_1(\mathit{natPrim})) : \Defaultable(\Int \join \Bool)$}
  \end{prooftree}
  \caption{Witness derivation for $contrav(i_\Nat(w), \mathit{in}_1(\mathit{natPrim})) : \Defaultable(\Int \join \Bool)$}
  \label{fig:witness-example-defaultable}
\end{figure}

\section{Coherence}

\subsection{Motivation}


\begin{figure}[ht]
  \centering
  \begin{subfigure}{0.4\textwidth}
    \begin{flalign*}
       & \instance{\Showable}{\Nat} :                                                         \\
       & \; \; \mathit{show} : \Nat \to \String                                       \\
       & \; \; \mathit{show} \; x := \caseof{x}                                               \\
       & \; \; \; \; Z \Rightarrow \mathit{"Z"}                                               \\
       & \; \; \; \; S(n) \Rightarrow \mathit{append} \; \mathit{"S"} \; (\mathit{show} \; n)
    \end{flalign*}
  \end{subfigure}
  \hfill
  \begin{subfigure}{0.4\textwidth}
    \begin{flalign*}
       & \instance{\Showable}{\Nat} :                                                         \\
       & \; \; \mathit{show} : \Nat \to \String                                       \\
       & \; \; \mathit{show} \; x := \caseof{x}                                               \\
       & \; \; \; \; Z \Rightarrow \mathit{"0"}                                               \\
       & \; \; \; \; S(n) \Rightarrow \mathit{append} \; \mathit{"S"} \; (\mathit{show} \; n)
    \end{flalign*}
  \end{subfigure}
  \caption{Incoherent instance declarations for $\Showable(\Nat)$}
  \label{fig:showable-nat}
\end{figure}

Consider the following instance declarations (fig. \ref{fig:showable-nat}):

If there is more than one instance declaration in the same environment for the same type class and type,
the program may be indeterministic.
If we call the method $\mathit{show}$ for an argument of type $\Nat$,
it is therefore undecidable which instance is being picked.

Incoherence causes unpredictable behavior of programs.
Not only does this potentially produce unexpected results, it also prevents us from reasoning about programs.
E.g. if the $\mathit{insert}$ operation for search tree relies on the type class $\mathit{Ord}$ for which we have incoherent instances,
the search tree properties may break. \cite{Kilpatrick2019-cy}

Moreover, in the presence of subtyping, instances for types related by the subtyping relation may not be declared for the same type class.

\subsection{Definition}

Using witnesses we may formalize type class coherence:

\begin{definition}
  Type class resolution is coherent if and only if for any pair of witnesses $i,j : \Phi(\tau)$ that witness the same predicate application we have $i \opeq j$.
\end{definition}

We can define operational equality $\opeq$ simply as two witnesses of a predicate application containing the same leaf, i.e. the same instance.
Therefore, the usage of these witnesses can always be expected to behave in the same way.
Witnesses always point to exactly one instance definition. Thus, it is sufficient show that for any pair of witnesses the leaf (i.e. the instance) is the same.

\subsection{Consequences}

Following this there are some constraints we have to impose on type class resolution.
Generally, if there is an instance declaration for $\Psi(\tau)$ and if $\tau \sub \sigma$ or $\sigma \sub \tau$ there cannot be another instance declaration for $\Psi(\sigma)$.
Otherwise, we could have the following two derivations with different witnesses if there is a subtyping derivation $\mathscr{D}$ for a witness $m : \tau \sub \sigma$:

\begin{prooftree}
  \AxiomC{$w : \instance{\Phi^+}{\tau}$}
  \RightLabel{\textsc{Decl}}
  \UnaryInfC{$i_\tau(w) : \Phi^+(\tau)$}
\end{prooftree}

\begin{prooftree}
  \AxiomC{$w' : \instance{\Phi^+}{\sigma}$}
  \RightLabel{\textsc{Decl}}
  \UnaryInfC{$i(w') : \Phi^+(\sigma)$}
  \AxiomC{$\mathscr{D}$}
  \noLine
  \UnaryInfC{$m : \tau \sub \sigma$}
  \RightLabel{\textsc{CoV}}
  \BinaryInfC{$\cov(i(w'),m) : \Phi^+(\tau)$}
\end{prooftree}

For contravariant predicates and given a derivation $\mathscr{D}'$ for a witness $m : \sigma \sub \tau$ we could have:

\begin{prooftree}
  \AxiomC{$w : \instance{\Phi^-}{\tau}$}
  \RightLabel{\textsc{Decl}}
  \UnaryInfC{$i_\tau(w) : \Phi^-(\tau)$}
\end{prooftree}

\begin{prooftree}
  \AxiomC{$w' : \instance{\Phi^-}{\sigma}$}
  \RightLabel{\textsc{Decl}}
  \UnaryInfC{$i(w') : \Phi^-(\sigma)$}
  \AxiomC{$\mathscr{D}'$}
  \noLine
  \UnaryInfC{$m : \sigma \sub \tau$}
  \RightLabel{\textsc{ContraV}}
  \BinaryInfC{$\contrav(i(w'),m) : \Phi^-(\tau)$}
\end{prooftree}

Note that in order for coherence to be satisfied, derivations do not have to be unique.
Instead of the first derivation we may also use the following additionally using the \textsc{Refl} rule:

\begin{prooftree}
  \AxiomC{$w : \instance{\Phi^+}{\tau}$}
  \RightLabel{\textsc{Decl}}
  \UnaryInfC{$i_\tau(w) : \Phi^+(\tau)$}
  \AxiomC{}
  \RightLabel{\textsc{Refl}}
  \UnaryInfC{$\refl_\tau : \tau \sub \tau$}
  \RightLabel{\textsc{CoV}}
  \BinaryInfC{$\cov(i_\tau(w),\refl_\tau) : \Phi^+(\tau)$}
\end{prooftree}

Since the derivation rules for qualified types do not branch, there will always be exactly one leaf in the derivation rule given as an instance declaration.
Thus it suffices to show that for every judgement there  may be multiple witnesses but the corresponding instance declaration is unique.
To achieve this, instances must be non-overlapping.

Additionally, in some systems with subtyping there may be overlapping types which are not themselves in a subtyping relation with each other.
In our type system, an example for this would be the types $\Singleton{0} \join \Singleton{1}$ and $\Singleton{1} \join \Singleton{2}$.
Given $\Phi(\Singleton{0} \join \Singleton{1})$ and $\Phi(\Singleton{1} \join \Singleton{2})$, the judgement $\Phi(\Singleton{1})$ could be derived in two ways.
In order to maintain coherence in this case, we have to ensure that witnesses for these judgements are derived from a common instance.
We can not, however, declare an instance for both types individually.

Generally, a global restriction follows when declaring instances:
There may not be an instance for an overlapping type in scope.
How this can be checked algorithmically is presented in chapter \ref{ch:type-system}.

\section{Inclusive Subtyping}

We assume a naive set-theoretic definition of subtyping analagous to the one given by Castagna and Xu \cite{castagna}:

\begin{definition} Subtyping\\
  $\tau \sub \sigma \Leftrightarrow [\tau] \subseteq [\sigma]$ where $[\tau]$ is the set  of all witnesses of $\tau$.
\end{definition}

This notion of subtyping trivially satsifies the Liskov substitution principle.
Because with $\tau \sub \sigma$ for every $e : \tau$ we also have $e : \sigma$, the coercion function is the identity.
Thus all properties are preserved for terms over the subtyping relation.

With the types at hand, this is easy to follow.
We can trivially translate the types of $\Nat$ and $\Int$ into corresponding sets.
The singleton types can be interpreted as $\Singleton{0} \rightsquigarrow \{0\}$, $\Singleton{1} \rightsquigarrow \{1\}$, \dots
Adding lattice types $\bot \rightsquigarrow \emptyset$ and $\top \rightsquigarrow \{ S | \forall M. M \subseteq S \}$,  we also have correspondents to union and intersection types with the union and intersection of sets.

Given inclusive subtyping, it we may be motivated to introduces some other rules.
E.g. given $\Showable(\Bool)$ and $\Showable(\Nat)$, it may seem tempting to derive $\Showable(\Bool \join \Nat)$,
so that the term $\lambda b. \showTerm(\ifthenelseTerm b \; b \; 42)$ is typeable.
Introducing union types can only be done with some restrictions:

\begin{prooftree}
  \AxiomC{$\ctx \Phi^+(\rho)$}
  \AxiomC{$\tau \sub \rho$}
  \AxiomC{$\sigma \sub \rho$}
  \RightLabel{\textsc{JoinI}}
  \BinaryInfC{$\tau \join \sigma \sub \rho$}
  \alwaysSingleLine
  \RightLabel{\textsc{CoV}}
  \BinaryInfC{$\ctx \Phi^+(\tau \join \sigma)$}
\end{prooftree}

The \textsc{Join} rule can not be derived with the subtyping rules because $\tau \join \sigma$ is neither a subtype of $\tau$ nor of $\sigma$.
In fact, only the opposite holds.
However, there is a motivation for it:
With the definition of covariant predicates the premises express that for all terms of type $\tau$ and $\sigma$ the characteristic property holds.
Since every term of type $\tau \join \sigma$ is a term of type $\tau$ or $\sigma$, $\Phi(\tau \join \sigma)$ holds.

\begin{prooftree}
  \alwaysNoLine
  \AxiomC{$\ctx \Phi^+(\sigma)$}
  \AxiomC{$\ctx \Phi^+(\tau)$}
  \alwaysSingleLine
  \RightLabel{\textsc{Join}$^+$}
  \BinaryInfC{$\ctx \Phi^+(\tau\join\sigma)$}
\end{prooftree}

Dually, introducing intersection types can also only be done with some restrictions:

\begin{prooftree}
  \AxiomC{$\ctx \Phi^-(\tau)$}
  \AxiomC{$\tau \sub \sigma$}
  \AxiomC{$\tau \sub \rho$}
  \RightLabel{\textsc{MeetI}}
  \BinaryInfC{$\tau \sub \sigma \meet \rho$}
  \alwaysSingleLine
  \RightLabel{\textsc{ContraV}}
  \BinaryInfC{$\ctx \Phi^-(\sigma \meet \rho)$}
\end{prooftree}

The \textsc{Meet} rule can not be derived with the subtyping rules because $\tau \meet \sigma$ is neither a supertype of $\tau$ nor of $\sigma$.
With the definition of contravariant predicates the premises express that for some witnesses of $\tau$ and $\sigma$ the characteristic property holds.
But even though this rule is dual to the \textsc{Join}-rule above, we cannot motivate it.
If some witness of $\tau \meet \sigma$ is a witness of both $\tau$ and $\sigma$, $\Phi(\tau \meet \sigma)$ holds.
However, there is no guarantee that a term of type $\tau$ or of type $\sigma$ is also of type $\tau \meet \sigma$, e.g. if $\tau \meet \join = \bot$.
% this rule is bogus:
% if \tau and \sigma are disjoint there is no possible witness in \tau \meet \sigma...

\begin{prooftree}
  \alwaysNoLine
  \AxiomC{$\ctx \Phi^-(\sigma)$}
  \AxiomC{$\ctx \Phi^-(\tau)$}
  \alwaysSingleLine
  \RightLabel{\textsc{Meet}$^-$}
  \BinaryInfC{$\ctx \Phi^-(\tau\meet\sigma)$}
\end{prooftree}


In the end however, we can only resolve these constraints if the predicate in question is monotonous on the witnesses of a type.
Predicates that relate witnesses with each other such as $\Ordable$ are not trivially satisfied for the union of two types if they hold for both respectively.
Consider an ordering of natural numbers $o_\Nat : \Ordable \Nat$ and an ordering of booleans $o_\Bool : \Ordable \Bool$.
It is not ambiguous how to define the ordering $o : \Ordable (\Nat \join \Bool)$.
$o(\mathbf{true}, 1)$ has to be defined in some way, but since it is ambiguous we cannot define it without violating type class coherence.


The rules \textsc{Join}$^+$ and \textsc{Meet}$^-$ as mentioned before cannot be derived from the subtyping rules alone.
It may seem intuitive that given $Show \; \tau$ and $Show \; \sigma$ we also have $Show \; \tau \; \join \; \sigma$.
Dually we could also be able to resolve $Read \; \tau \; \meet \; \sigma$ from $Read \; \tau$ and $Read \; \sigma$.

However these rules cannot be implemented generally.
Consider type classes with methods in which the bound type variable occurs more than once (unlike in $Show$ and $Read$).
As an example where this rule cannot be implemented, let us look at the $Eq$ type class:

\begin{gather}
\nonumber {\bf class} \; Eq(a) \; where\\
\nonumber  eq : a \to a \to \Bool
\end{gather}

Given instances $Eq(\Nat)$ and $Eq(\Bool)$, we may expect to have $Eq(\Nat \join \Bool)$ but e.g. the term $eq \; 5 \; True$ cannot be trivially implemented based on known implementations for $eq$.
Based on the assumptions we already know how to compare terms of type $\Nat$ with each other and terms of type $\Bool$ with each other,
however we have no information available on how to compare a term of type $\Bool$ with a term of type $\Nat$.
In this example, it would be easy to provide $false$ as a default value but constructing default values is going to be complicated for more sophisticated type classes.
In fact the $Ord$ type class already would be problematic using default values.

Therefore, these non-derivable rules cannot be used for type class resolution.

% not a good counterexample: here we should just choose the "smaller" instance
% even though this is undecidable in other cases, see above

% More surprisingly perhaps, even finding an implementation for $\Readable(\tau \meet \sigma)$ can lead to problems.
% Consider the following instances for $\Readable(\Nat)$ and $\Readable(\Int)$:


% \begin{figure}[ht]
%   \centering
%   \begin{subfigure}{0.4\textwidth}
%   \begin{flalign*}
%   & \instance{\Readable}{\Nat} : \\
%   & \; \; \mathit{read} : \String \to \Nat \\
%   & \; \; \mathit{read} \; str := \; 0
%   \end{flalign*}
%   \end{subfigure}
%   \hfill
%   \begin{subfigure}{0.4\textwidth}
%   \begin{flalign*}
%   & \instance{\Readable}{\Int} : \\
%   & \; \; \mathit{read} : \String \to \Int \\
%   & \; \; \mathit{read} \; str := \; 1
%   \end{flalign*}
%   \end{subfigure}
% \label{fig:read-instances}
% \caption{Instances for $\Readable(\Nat)$ and $\Readable(\Int)$}
% \end{figure}

% The intersection type $\Nat \meet \Int$ is equivalent to $\Nat$.
% However, based on these instance declarations it is ambiguous whether the derived instance for $\Readable(\Nat \meet \Int)$ will be the same as the declared instance for $\Readable{\Nat}$.


% explain problems for intersection in contravariant type classes


There is a problem when we want to implement the union type.

Consider again the \texttt{Show} typeclass. It is intuitive to see how we can construct the \texttt{show} method for the union of two types, given that it is defined for both respecetively.
However, looking at the \texttt{Eq} typeclass, we can not generally deduce an instance of the join of two types.
If we solely know how to compare terms of type $\tau$ with each other and how to compare terms of type $\sigma$ with each other,
we do not know how to compare a term of type $\tau$ with a term of type $\sigma$, even though the derived instance tells we should be able to do so.

\begin{gather}
  \nonumber show_{a\join b} \; x := {\bf if} \; typeOf \; x == a \; {\bf then} \; show_a \; x \; {\bf else} \; show_b \; x
\end{gather}

We might be able to just return \texttt{False} as a default value in such cases but even default values can be ambiguous.
Consider now the \texttt{Ord} type class. Given \texttt{Ord a} and \texttt{Ord b} we may say that in \texttt{Ord a $\join$ b} every $a$ is ordered before $b$.
But given the commutativity of $\join$, this would violate type class coherence because $a \join b = b \join a$ but \texttt{Ord a $\join$ b} $\neq$ \texttt{Ord b $\join$ a}.


\section{Representations of Type Class Witnesses}
\label{sec:representations}

For an implementation, we need some representation of witnesses which is going to be used for the execution of programs using type class methods.
Since type classes hide the concrete implementation of their methods, we need a means to extract this concrete implementation when needed.
There are essentialy two ways to implement type class overloading in practise: Intensional type analysis which dispatches a type representation at runtime and dictionary passing which treats witnesses as records or dictionaries which can be resolved at compile time.

\subsection{Intensional type analysis}
\label{sec:intensional-analysis}

Instead of passing around dictionaries, we can also resolve the relevant instance at runtime dispatching on the term's type.
This requires our language to tag term with some representation of their type at runtime.
In the before mentioned case, the definition of \mintinline{Haskell}{show} could look something like this:

\begin{minted}{Haskell}
  show t x = case t of
    Bool -> boolShow x
    Int -> intShow x
\end{minted}

In the context of subtyping we would not require type equality but for \mintinline{Haskell}{t} to be a subtype of some type for which an instance is defined.
This also renders intensional type analysis more difficult:
We can not simply match on a type (or its encoded representation \cite{weirich2000}) because we have to essentially solve the problem of subtyping between the type at hand and (at worst case) for each type for which an instance declaration is in scope.
So, intensional type analysis may introduce a dramatic overhead in the presence of subtyping.

This overhead seems natural when we want to implement a dynamically type checked language.
However, type class resolution should already guarantee us static type safety, so additionally using type tags for dynamic type checking or type analysis seems superfluous.
The only case for which intensional type analysis appears superior is for the case of union and intersection types.


\subsection{Dictionary Passing}
\label{sec:dictionaryPassing}

One typical way of implementing type classes is using \emph{dicitonary passing style}.
To examine this, we look at type classes in Haskell.
We use an isomorphism between type classes and records:
E.g. the type class \mintinline{Haskell}{Eq} defined as

\begin{minted}{Haskell}
  class Eq a where
    eq :: a -> a -> Bool
    neq :: a -> a -> Bool
\end{minted}

can be translated to a record type that preserves the structure of the class:

\begin{minted}{Haskell}
  data DictEq a =
    DictEq { eq :: a -> a -> Bool,
             neq :: a -> a -> Bool }
\end{minted}

Instances as witnesses of type classes can be translated accordingly to values of dictionaries.
E.g.

\begin{minted}{Haskell}
  instance Eq Int where
    eq = intEq
    neq = not . intEq  
\end{minted}

can be translated to a value of type \mintinline{Haskell}{DictEq Int}:

\begin{minted}{Haskell}
  intEqDict = DictEq { eq = intEq,
                       neq = not . intEq }
\end{minted}

Here, the instances of a type class are carried in a dictionary that has to be passed as an additional argument to method calls.
For example the term

\begin{minted}{Haskell}
  show 5
\end{minted}

would be compiled to

\begin{minted}{Haskell}
  show showIntDict 5
\end{minted}

where \mintinline{Haskell}{showIntDict} is a dictionary that provides the relevant defintion of \mintinline{Haskell}{show :: Int -> String} for the instance of \mintinline{Haskell}{Show Int}.
This allows us to "compile away" the overhead that type classes introduce to the surface language because type inference can fill in the correct dictionary that is ought to be used.

Generic constrained functions like

\begin{minted}{Haskell}
  emphasize :: (Show a) => a -> String
  emphasize x = show x ++ "!"
\end{minted}

would simply pass around the dictionary and be compiled to something like:

\begin{minted}{Haskell}
  emphasize :: ShowDict a -> a -> String
  emphasize dict x = show dict x ++ "!"
\end{minted}

\cite{kiselyov}

There is a drawback however, in the presence of subtyping it may not always be clear which dictionary is going to be needed for instance resolution.
Consider the term:

\begin{minted}{text}
  show (if b then 42 :: Int else "Hello" :: String)
\end{minted}

The inferred type of this expression should be \mintinline{text}{Int \/ String}.
What we need here are essentially two dictionaries: One for \mintinline{text}{Int} and one for \mintinline{text}{String} because it is undecidable at compile time which dictionary is going to be used at runtime.
% Would it not be possible to just construct a new dictionary consisting of both variants?


\section{Type class coherence in the context of subtyping}
% Main thesis for class coherence with subtyping
To ensure type class coherence, we have to take conclusions of the subtyping relation into account.
That means we have to consider the derivable instances of type class based of sub- or supertypes.
This imposes some restrictions not present in type systems based on type equalities.

  For Hindley-Milner type systems we want to avoid \emph{overlapping instances}, i.e. instances for types that can be unified. \cite{peytonjones1997type}
  Syntactically, types are overlapping if one can be substituted for the other or they can be unified.
  E.g. $\mathit{List} \; \alpha$ and $\mathit{List} \; \Nat$ are overlapping with the substitution $\sigma(\alpha) \to \Nat$.
  In Haskell specifically, it is very easy to check an overlap, albeit more restrictive: We only need to syntactically check whether two types share the same head constructor ($\mathit{List}$ in the example above).

In the context of subtyping, overlaps of types have to be expressed differently because we no longer use unification for type inference but biunification.
In order to check for an overlap of types, we have to create the intersection of those types and check whether it is empty.

E.g. given $\instance \Phi a$ and $sub \sub a$ and $a \sub sup$, we can neither have $\instance \Phi{sub}$ , nor $\instance \Phi{sup}$,
as $\Phi(sup)$ would imply $\Phi(a)$ and $\Phi(a)$ would imply $\Phi(sup)$.

In the following, I want to give a motivation on why this would be problematic.
Consider we have $\Nat \sub \Int$.
We can implement Monoid instances for both types. For natural numbers we choose multiplication as operator and accordingly 1 as neutral element.
For integers on the other hand, we might prefer to choose addition as operator and 0 as neutral element, so we can expand to monoid to a group.

Building programs on top of these instances is going to get tedious as it will often occur that the more specific \texttt{Nat} type will be inferred,
even if only want to deal with integers.
Using the append operator exposed by the Monoid typeclass, therefore may lead to unexpected behavior.
% Note for a good example, we need a good notion of type inference for this case, which is currently not implemented.

In the simple arithmetic expression $(a \oplus b) \oplus c$ $\oplus$ can have two different meanings based on the inferred types of $a,b$ and $c$.
Since type inferrence with subtyping is generally not quite obvious it may seem

  It may seem that we could choose the most specific instance. This, however, might have unexpected results.
  E.g. if we have $\mathit{NonEmptyList} \; \alpha \sub \mathit{List} \; \alpha$, we may not know during compilation whether $\mathit{NonEmptyList} \; \alpha $ or $\mathit{List} \; \alpha$ is being picked.
  ~Generally to infer the most specific type seems very hard. In this example filtering a $\mathit{NonEmptyList}$ may or may not return an empty list and we may just have to assume that it is possibly empty.
  This may lead to hard to track behaviour when using overlapping instances.

A simple example for undecidable most specific instances can be better given with record types.
If we need to resolve an instance for $C \{x : Int\}$ and we already have instances for $C \{x : Int, y : Int\}$ and $C \{x : Int, z : Int\}$ neither instance is more specific than the other.


A means to ensure type class coherence could be the following:
Since for any pair of types $\tau$ and $\sigma$ that have a common subtype $\rho$ with $\rho \sub \tau$ and $\rho \sub \sigma$ having different witnesses for $\Phi(\tau)$ and $\Phi(\sigma)$ would lead to different witnesses for $\Phi(\rho)$,
we have to ensure that $\tau \meet \sigma$ is equivalent to the empty type $\bot$.
We can do so by constructing the intersection of the type automata for $\tau$ and $\sigma$ and checking whether this automaton accepts the empty language.

% NEED TO REWORK THE PREVIOUS PARAGRAPHES

Resolution already guarantees that there is at most one instance resolved for any predicate application.
This instance has to be uniquely determined in order for type class coherence to be satisfied.
Thus, we need to enforce that there is at no point more than one instance in scope to witness a predicate application.

\subsubsection{Covariant Predicates}

Covariant predicates allow resolution 'downwards', i.e. instances for subtypes can be resolved from instances for supertypes.
We therefore need to ensure globally that there is no common subtype (except the trivial type $\bot$) for which an instance can be resolved from two distinct instances.
That means the types that we declare instances for have to be \emph{non-overlapping downwards}.

\begin{definition}
  Two types $\tau$ and $\sigma$ are \emph{non-overlapping downwards} iff. $\forall\rho. \rho \sub \tau$ and $\rho \sub \sigma \Rightarrow \rho = \bot$.
\end{definition}

This condition is equivalent to the intersection type $\tau \meet \sigma$ being empty.
Since there is no expression $e : \bot$, deriving $\Phi(\bot)$ does not lead to any ambiguity and preserves type class coherence.
Algorithmically, this can be enforced using type automata which will be presented in the chapter \ref{ch:type-system}.

Given any covariant type class $\Phi^+$ and instances for $\Phi^+(\Singleton{0} \join \Singleton{1})$ and $\Phi^+(\Singleton{1} \join \Singleton{2})$,
the intersection of both types is equivalent to $(\Singleton{0} \join \Singleton{1}) \meet \Singleton{1} \join \Singleton{2} = \Singleton{1} \neq \bot$, so type class coherence would be violated because the instance for $\Singleton{1}$ is ambiguous.

\subsubsection{Contravariant Predicates}

Contravariant predicates, on the other hand, allow resolution 'upwards', i.e. instances for supertypes can be resolved from instances for subtypes.
Here, we have to enforce globally that there is no common supertype (except the trivial type $\top$) for which an instance can be resolved from two distinct instances.
That means the types that we declare instances for have to be \emph{non-overlapping upwards}.

\begin{definition}
  Two types $\tau$ and $\sigma$ are \emph{non-overlapping upwards} iff. $\forall\rho. \tau \sub \rho$ and $\sigma \sub \rho \Rightarrow \rho = \top$.
\end{definition}

This condition is equivalent to $\tau \join \sigma = \top$.
Enforcing this in our type system would be very restrictive.
In more sophisticated type systems, it may not even be possible to find a non-trivial type $\tau^{-1} \neq \top$, such that $\tau \join \tau^{-1} = \top$.


\subsubsection{Invariant Predicates}

Invariant predicates allow resolution neither 'upwards' nor 'downwards', thus no such restriction is required for them.
We only need to enforce that there is no instance for an equivalent type declared.