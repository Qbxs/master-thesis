\chapter{Qualified Types}
\label{ch:qualified-types}

We generalise the notion of type classes as \emph{qualified types}. \cite{jones2003qualified}
When types instantiate a type class, we say that they satisfy a predicate which is given by the type class declaration.
E.g. if a type $\tau$ instantiates the type class $\Showable$, we can derive the judgement $\Showable(\tau)$.

\section{Theory of Predicates}
\label{sec:theory-predicates}

Formally, we can define predicates over types as follows:

\begin{definition} Predicates\\
  Given a universe of types $\mathcal{U}$, a \emph{predicate over types} $\Phi$ is an element of $\mathcal{P}(\mathcal{U})$.
\end{definition}

We only consider predicates that are preserved over the subtyping lattice.
I.e. predicates that depend only on the terms of a type.
That means only predicates that are \emph{monotonous} are considered while other predicates about meta-information such as \emph{"has exactly two values"} are disregarded.
We further differentiate between \emph{covariant}, \emph{contravariant} and \emph{invariant} predicates over types, because the resolution rules vary accordingly.

Let $\Gamma$ be the context of facts, i.e. known types that satisfy specific predicates.

\subsection{Covariant Predicates}
\label{sec:covariant-predicates}



\begin{definition}
  A \emph{covariant type class predicate} $\Phi^<$ is a predicate preserved by the subtyping relation, i.e. it adheres to the following rule:
\end{definition}

% The monotonicity of $\Phi^<$ motivates the following rule preserving the predicate for subtypes.
% From the definition of covariant predicates it follows that $\phi$ holds for every term of $\sigma$ and because every witness of $\tau$ is also a witness of $\sigma$ the characteristic property $\phi$ holds for all witnesses of $\tau$.

% ^< statt ^<

\begin{prooftree}
  \AxiomC{$\ctx \Phi^<(\sigma)$}
  \AxiomC{$\tau \sub \sigma$}
  \alwaysSingleLine
  \RightLabel{\textsc{CoV}}
  \BinaryInfC{$\ctx \Phi^<(\tau)$}
\end{prooftree}

With \textsc{CoV} and the subtyping rules in fig. \ref{fig:subtyping} we can derive several useful rules. (fig. \ref{fig:derived-covariant-rules})
In the lattice of types, the types that satisfy a covariant predicate form a \emph{downwards closed set}.

\begin{figure}[ht]
  \begin{center}
    \AxiomC{$\ctx \Phi^<(\top)$}
    \AxiomC{}
    \RightLabel{\textsc{Top}}
    \UnaryInfC{$\tau \sub \top$}
    \alwaysSingleLine
    \RightLabel{\textsc{CoV}}
    \BinaryInfC{$\ctx \Phi^<(\tau)$}
    \DisplayProof
    \deriveRule
    \AxiomC{$\ctx \Phi^<(\top)$}
    \alwaysSingleLine
    \RightLabel{\textsc{Top}$^<$}
    \UnaryInfC{$\ctx \Phi^<(\tau)$}
    \DisplayProof
  \end{center}

  \begin{center}
    \AxiomC{$\ctx \Phi^<(\tau)$}
    \AxiomC{}
    \RightLabel{\textsc{Bot}}
    \UnaryInfC{$\bot \sub \tau$}
    \alwaysSingleLine
    \RightLabel{\textsc{CoV}}
    \BinaryInfC{$\ctx \Phi^<(\bot)$}
    \DisplayProof
    \deriveRule
    \AxiomC{$\ctx \Phi^<(\tau)$}
    \alwaysSingleLine
    \RightLabel{\textsc{Bot}$^<$}
    \UnaryInfC{$\ctx \Phi^<(\bot)$}
    \DisplayProof
  \end{center}

  \begin{center}
    \AxiomC{$\ctx \Phi^<(\tau)$}
    \AxiomC{}
    \RightLabel{\textsc{Refl}}
    \UnaryInfC{$\tau \sub \tau$}
    \RightLabel{\textsc{MeetI}$_1$}
    \UnaryInfC{$\tau \meet \sigma \sub \tau$}
    \alwaysSingleLine
    \RightLabel{\textsc{CoV}}
    \BinaryInfC{$\ctx \Phi^<(\tau \meet \sigma)$}
    \DisplayProof
    \deriveRule
    \AxiomC{$\ctx \Phi^<(\tau)$}
    \alwaysSingleLine
    \RightLabel{\textsc{Meet}$_1^<$}
    \UnaryInfC{$\ctx \Phi^<(\tau \meet \sigma)$}
    \DisplayProof
  \end{center}

  \begin{center}
    \AxiomC{$\ctx \Phi^<(\tau)$}
    \AxiomC{}
    \RightLabel{\textsc{Refl}}
    \UnaryInfC{$\tau \sub \tau$}
    \RightLabel{\textsc{MeetI}$_2$}
    \UnaryInfC{$\sigma \meet \tau \sub \tau$}
    \alwaysSingleLine
    \RightLabel{\textsc{CoV}}
    \BinaryInfC{$\ctx \Phi^<(\sigma \meet \tau)$}
    \DisplayProof
    \deriveRule
    \AxiomC{$\ctx \Phi^<(\tau)$}
    \alwaysSingleLine
    \RightLabel{\textsc{Meet}$_2^<$}
    \UnaryInfC{$\ctx \Phi^<(\sigma \meet \tau)$}
    \DisplayProof
  \end{center}

  \begin{center}
    \AxiomC{$\ctx \Phi^<(\Int)$}
    \AxiomC{}
    \RightLabel{\textsc{NatPrim}}
    \UnaryInfC{$\Nat \sub \Int$}
    \alwaysSingleLine
    \RightLabel{\textsc{CoV}}
    \BinaryInfC{$\ctx \Phi^<(\Nat)$}
    \DisplayProof
    \deriveRule
    \AxiomC{$\ctx \Phi^<(\Int)$}
    \alwaysSingleLine
    \RightLabel{\textsc{NatPrim}$^<$}
    \UnaryInfC{$\ctx \Phi^<(\Nat)$}
    \DisplayProof
  \end{center}

  \caption{Derived rules for covariant predicates}
  \label{fig:derived-covariant-rules}
\end{figure}

A typical example for covariant predicates is $\Showable$: all types that are showable, which generally rules out function types.
The \textsc{CoV} rule seems intuitive for this:
If $e : \tau$ is a showable term and $\tau \sub \sigma$, then $e : \sigma$ can be shown in the same way.

\subsection{Contravariant Predicates}
\label{sec:contravariant-predicates}

\begin{definition}
  A \emph{contravariant type class predicate} $\Phi^>$ is a predicate preserved by the supertyping or flipped subtyping relation, i.e. it adheres to the following rule:
\end{definition}

Contravariant predicates describe properties about the lower bounds of types.
That means they are inherited by all supertypes of a type that they satisfy.
In the lattice of types, the types that satisfy a contravariant predicate form an \emph{upwards closed set}.
E.g. if a type is defaultable, i.e. we can define a default value of that type, then all of its supertypes are defaultable as well because we can simply 'reuse' the default value for all supertypes.


\begin{prooftree}
  \alwaysNoLine
  \AxiomC{$\ctx \Phi^>(\sigma)$}
  \AxiomC{$\sigma \sub \tau$}
  \alwaysSingleLine
  \RightLabel{\textsc{ContraV}}
  \BinaryInfC{$\ctx \Phi^>(\tau)$}
\end{prooftree}

The rules for contravariant predicates are dual to those for covariant predicates.
The monotonicity of $\Phi^>$ motivates the following rule preserving the predicate for supertypes:

With \textsc{ContraV} and the subtyping rules in fig. \ref{fig:subtyping} we can again derive several useful rules. (fig. \ref{fig:contravariant-derived-rules})

\begin{figure}[ht]
  \begin{center}
    \AxiomC{$\ctx \Phi^>(\tau)$}
    \AxiomC{}
    \RightLabel{\textsc{Top}}
    \UnaryInfC{$\tau \sub \top$}
    \alwaysSingleLine
    \RightLabel{\textsc{ContraV}}
    \BinaryInfC{$\ctx \Phi^>(\top)$}
    \DisplayProof
    \deriveRule
    \AxiomC{$\ctx \Phi^>(\tau)$}
    \alwaysSingleLine
    \RightLabel{\textsc{Top}$^>$}
    \UnaryInfC{$\ctx \Phi^>(\top)$}
    \DisplayProof
  \end{center}

  \begin{center}
    \AxiomC{$\ctx \Phi^>(\bot)$}
    \AxiomC{}
    \RightLabel{\textsc{Bot}}
    \UnaryInfC{$\bot \sub \tau$}
    \alwaysSingleLine
    \RightLabel{\textsc{ContraV}}
    \BinaryInfC{$\ctx \Phi^>(\tau)$}
    \DisplayProof
    \deriveRule
    \AxiomC{$\ctx \Phi^>(\bot)$}
    \alwaysSingleLine
    \RightLabel{\textsc{Bot}$^>$}
    \UnaryInfC{$\ctx \Phi^>(\tau)$}
    \DisplayProof
  \end{center}

  \begin{center}
    \AxiomC{$\ctx \Phi^>(\tau)$}
    \AxiomC{}
    \RightLabel{\textsc{Refl}}
    \UnaryInfC{$\tau \sub \tau$}
    \RightLabel{\textsc{JoinI}$_1$}
    \UnaryInfC{$\tau \sub \tau \join \sigma$}
    \alwaysSingleLine
    \RightLabel{\textsc{ContraV}}
    \BinaryInfC{$\ctx \Phi^>(\tau \join \sigma)$}
    \DisplayProof
    \deriveRule
    \AxiomC{$\ctx \Phi^>(\tau)$}
    \alwaysSingleLine
    \RightLabel{\textsc{Join}$_1^>$}
    \UnaryInfC{$\ctx \Phi^>(\tau \join \sigma)$}
    \DisplayProof
  \end{center}

  \begin{center}
    \AxiomC{$\ctx \Phi^>(\tau)$}
    \AxiomC{}
    \RightLabel{\textsc{Refl}}
    \UnaryInfC{$\tau \sub \tau$}
    \RightLabel{\textsc{JoinI}$_2$}
    \UnaryInfC{$\tau \sub \sigma \join \tau$}
    \alwaysSingleLine
    \RightLabel{\textsc{ContraV}}
    \BinaryInfC{$\ctx \Phi^>(\sigma \join \tau)$}
    \DisplayProof
    \deriveRule
    \AxiomC{$\ctx \Phi^>(\tau)$}
    \alwaysSingleLine
    \RightLabel{\textsc{Join}$_2^>$}
    \UnaryInfC{$\ctx \Phi^>(\sigma \join \tau)$}
    \DisplayProof
  \end{center}

  \begin{center}
    \AxiomC{$\ctx \Phi^>(\Nat)$}
    \AxiomC{}
    \RightLabel{\textsc{NatPrim}}
    \UnaryInfC{$\Nat \sub \Int$}
    \alwaysSingleLine
    \RightLabel{\textsc{ContraV}}
    \BinaryInfC{$\ctx \Phi^>(\Int)$}
    \DisplayProof
    \deriveRule
    \AxiomC{$\ctx \Phi^>(\Nat)$}
    \alwaysSingleLine
    \RightLabel{\textsc{NatPrim}$^>$}
    \UnaryInfC{$\ctx \Phi^>(\Int)$}
    \DisplayProof
  \end{center}
  \caption{Derived rules for contravariant predicates}
  \label{fig:contravariant-derived-rules}
\end{figure}

A typical example for covariant predicates is $\Defaultable$: all types for which some default value can be predefined, which also generally rules out function types and empty types.
The \textsc{ContraV} rule, again, seems intuitive for this: \todo{repeat from above}
% fix:
If $e : \tau$ is a default value for $\tau$ and $\sigma \sub \tau$, then $e : \sigma$ can be used as a default value for $\sigma$ as well.


% \begin{center}
%   \alwaysNoLine
%   \AxiomC{$\ctx \Phi^>(\tau \meet \sigma)$}
%   \alwaysSingleLine
%   \RightLabel{\textsc{Meet}$_1^>$}
%   \UnaryInfC{$\ctx \Phi^>(\tau)$}
%   \DisplayProof
%   {\hskip.2in}
%   \alwaysNoLine
%   \AxiomC{$\ctx \Phi^>(\tau \meet \sigma)$}
%   \alwaysSingleLine
%   \RightLabel{\textsc{Meet}$_2^>$}
%   \UnaryInfC{$\ctx \Phi^>(\sigma)$}
%   \DisplayProof
% \end{center}

We omit the $^<$ and $^>$ superscripts if the variance of predicates does not matter.
Using this notation we can simplify axioms and the rule for constraints.
The rule for axioms is trivial: We can resolve known facts directly from the context.

\begin{prooftree}
  \AxiomC{}
  \RightLabel{\textsc{Axiom}}
  \UnaryInfC{$\Gamma, \Phi(\tau) \vdash \Phi(\tau)$}
\end{prooftree}

\subsection{Invariant Predicates}
\label{sec:invariant-predicates}

Invariant predicates describe properties about the lower \emph{and} upper bounds of types.

\begin{definition}
  An \emph{invariant type class predicate} $\Phi$ is a predicate preserved by the subtyping \emph{and} flipped subtyping relation, i.e. it adheres to the following rule:
\end{definition}
\todo{syntax for invariant predicates (superscript)}

\begin{prooftree}
  \alwaysNoLine
  \AxiomC{$\ctx \Phi(\sigma)$}
  \AxiomC{$\sigma \sub \tau$}
  \AxiomC{$\tau \sub \sigma$}
  \alwaysSingleLine
  \RightLabel{\textsc{InV}}
  \TrinaryInfC{$\ctx \Phi(\tau)$}
\end{prooftree}

Invariant type class predicates can essentially only be derived from type equalitites, i.e. where a type is both a sub- and supertype of another.
Hence, there are no interesting derivable rules for them.

A typical example for invariant predicates is $\Monoid$, satisfied by any type for which we can define a monoid, i.e. there is a total function combining two values of the type to a new one and a neutral element corresponding to this operation.
A monoid is represented by an invariant type class because the function both consumes and produces terms of the type to be declared a monoid.
\todo{give more theoretical explanation}

\subsection{Predicate Implications}
\label{sec:predicate-implications}

\todo{possibly unnecessary section}
Predicates may be constrained, i.e. they depend on other predicates.
$\Phi(\tau) \Rightarrow \Psi(\tau)$ means $\Psi$ is constrained by $\Phi$.
Thus, if $\Psi(\tau)$ is satisfied, then the constraint $\Phi(\tau)$ is satisfied as well.
Note that this corresponds to implications even though the arrow is flipped as it is oriented towards constraints.

\begin{prooftree}
  \AxiomC{$\ctx \Psi(\tau)$}
  \AxiomC{$\ctx \Phi(\tau) \Rightarrow \Psi(\tau)$}
  \RightLabel{\textsc{Constr}}
  \BinaryInfC{$\Gamma \vdash \Phi(\tau)$}
\end{prooftree}

As an example, the type class $\Ordable$ depends on the type class $\Eq$ as we need to have a notion of equality of terms to define an ordering of terms.
We thus write $\Eq(\tau) \Rightarrow \Ordable(\tau)$.

\subsection{Examples}

Consider the predicates $\Showable$ and $\Defaultable$.
A type $\tau$ satsifies the covariant predicate $\Showable$ if a total function of $\tau \to String$ can be defined.
Dually, a type $\tau$ satsifies the contravariant predicate $\Defaultable$ if a value of type $\tau$ can be defined.

Let context $\Gamma := \{ \Showable(\Int), \Defaultable(\Nat),  \Monoid(\Nat) \}$.
We obtain the following derivations for $\Showable(\Singleton{1} \meet \Nat)$:
We can interpret the derivation in fig. \ref{fig:example-showable} as a proof for \emph{Given a way to show an integer, we can also show anything that is both a natural number and of the singleton type $\Singleton{1}$} and

\begin{figure}[ht]
  \begin{prooftree}
    \AxiomC{}
    \RightLabel{\textsc{Axiom}}
    \UnaryInfC{$\ctx \Showable(\Int)$}
    \RightLabel{\textsc{Prim}$^<$}
    \UnaryInfC{$\ctx \Showable(\Nat)$}
    \RightLabel{\textsc{Meet}$^<_2$}
    \UnaryInfC{$\ctx \Showable(\Singleton{1} \meet \Nat)$}
  \end{prooftree}
  \caption{Derivation for $\ctx \Showable(\Singleton{1} \meet \Nat)$}
  \label{fig:example-showable}
\end{figure}

Using $\Gamma$ from above, we can derive $\Defaultable(\Int \join \Bool)$ (fig. \ref{fig:example-defaultable}).
In natural language this proves that \emph{given a default value for $\Nat$, we also obtain a default value for the union of $\Int$ and $\Bool$}


\begin{figure}[ht]
  \begin{prooftree}
    \AxiomC{}
    \RightLabel{\textsc{Axiom}}
    \UnaryInfC{$\ctx \Defaultable(\Nat)$}
    \RightLabel{\textsc{Prim}$^>$}
    \UnaryInfC{$\ctx \Defaultable(\Int)$}
    \alwaysSingleLine
    \RightLabel{\textsc{Join}$^>_1$}
    \UnaryInfC{$\ctx \Defaultable(\Int \join \Bool)$}
  \end{prooftree}
  \caption{Derivation for $\ctx \Defaultable(\Int \join \Bool)$}
  \label{fig:example-defaultable}
\end{figure}

Finally, again using $\Gamma$ defined above, we can prove judgements for invariant predicates for non syntactically equal types.
The derivation in fig. \ref{fig:example-monoid} combines the \textsc{InV}-rule with a proof that $\Nat$ and $\Nat \join \Singleton{1}$ are equivalent to prove that we can derive $\Monoid(\Nat \join \Singleton{1})$ from $\Monoid(\Nat)$.

\begin{figure}[ht]
  \begin{prooftree}
    \AxiomC{}
    \RightLabel{\textsc{Axiom}}
    \UnaryInfC{$\ctx \Monoid(\Nat)$}
    \AxiomC{}
    \RightLabel{\textsc{Refl}}
    \UnaryInfC{$\Nat \sub \Nat$}
    \RightLabel{\textsc{JoinI}$_1$}
    \UnaryInfC{$\Nat \sub \Nat \join \Singleton{1}$}
    \AxiomC{}
    \RightLabel{\textsc{Refl}}
    \UnaryInfC{$\Nat \sub \Nat$}
    \AxiomC{}
    \RightLabel{\textsc{SingletonPrim}$_1$}
    \UnaryInfC{$\Singleton{1} \sub \Nat$}
    \RightLabel{\textsc{JoinI}}
    \BinaryInfC{$\Nat \join \Singleton{1} \sub \Nat$}
    \RightLabel{\textsc{Axiom}}
    \alwaysSingleLine
    \RightLabel{\textsc{InV}}
    \TrinaryInfC{$\ctx \Monoid(\Nat \join \Singleton{1})$}
  \end{prooftree}
  \caption{Derivation for $\ctx \Monoid(\Nat \join \Singleton{1})$}
  \label{fig:example-monoid}
\end{figure}

\section{Witnesses}
\label{sec:witnesses}

By annotating applications of predicates with specific witnesses we obtain a calculus
that is not only able to prove that a type satisfies a predicate but also constructs concrete evidence for such a judgement.

Constructing witnesses directly corresponds to type class resolution if we interpret type classes as predicates on types.
Multiple witnesses can be derived for the same judgement but in order to preserve type class coherence they have to satsify some form of equivalence, as we will discuss later.
We again differentiate co-, contra-  and invariant type classes in order to transport type classes over the subtyping relation.

The witness rules in fig. \ref{fig:subtyping-witnesses} are an expansion of the subtyping rules in section \ref{sec:subtyping-rules}.

\begin{figure}[ht]
  % refl
  \begin{prooftree}
    \AxiomC{}
    \RightLabel{\textsc{Refl}}
    \UnaryInfC{$\refl_\tau : \tau \sub \tau$}
  \end{prooftree}

  % trans
  \begin{prooftree}
    \AxiomC{$f : \tau \sub \sigma$}
    \AxiomC{$g : \sigma \sub \rho$}
    \RightLabel{\textsc{Trans}}
    \BinaryInfC{$f \comp g : \tau \sub \rho$}
  \end{prooftree}

  % top/bot
  \begin{center}
    \AxiomC{}
    \RightLabel{\textsc{Top}}
    \UnaryInfC{$\topW_\tau : \tau \sub \top$}
    \DisplayProof
    {\hskip.2in}
    \AxiomC{}
    \RightLabel{\textsc{Bot}}
    \UnaryInfC{$\botW_\tau : \bot \sub \tau$}
    \DisplayProof
  \end{center}

  % join intro
  \begin{center}
    \AxiomC{$f : \tau \sub \sigma$}
    \RightLabel{\textsc{JoinI}$_1$}
    \UnaryInfC{$\inW{1}(f) : \tau \sub \sigma \join \rho$}
    \DisplayProof
    {\hskip.2in}
    \AxiomC{$f: \tau \sub \sigma$}
    \RightLabel{\textsc{JoinI}$_2$}
    \UnaryInfC{$\inW{2}(f) : \tau \sub \rho \join \sigma$}
    \DisplayProof
  \end{center}

  \begin{prooftree}
    \AxiomC{$f : \tau \sub \rho$}
    \AxiomC{$g : \sigma \sub \rho$}
    \RightLabel{\textsc{JoinI}}
    \BinaryInfC{$\joinW(f,g) : \tau \join \sigma \sub \rho$}
  \end{prooftree}

  % meet intro
  \begin{center}
    \AxiomC{$f : \tau \sub \rho$}
    \RightLabel{\textsc{MeetI}$_1$}
    \UnaryInfC{$\proj{1}(f) : \tau \meet \sigma \sub \rho$}
    \DisplayProof
    {\hskip.2in}
    \AxiomC{$f : \sigma \sub \rho$}
    \RightLabel{\textsc{MeetI}$_2$}
    \UnaryInfC{$\proj{2}(f) : \tau \meet \sigma \sub \rho$}
    \DisplayProof
  \end{center}

  \begin{prooftree}
    \AxiomC{$f : \tau \sub \sigma$}
    \AxiomC{$g : \tau \sub \rho$}
    \RightLabel{\textsc{MeetI}}
    \BinaryInfC{$\meetW(f,g) : \tau \sub \sigma \meet \rho$}
  \end{prooftree}

  \begin{prooftree}
    \AxiomC{}
    \RightLabel{\textsc{NatPrim}}
    \UnaryInfC{$\natPrim : \Nat \sub \Int$}
  \end{prooftree}

  \begin{prooftree}
    \AxiomC{$f : \tau' \sub \tau$}
    \AxiomC{$g : \sigma \sub \sigma'$}
    \RightLabel{\textsc{Func}}
    \BinaryInfC{$\funcW(f,g) : \tau \to \sigma \sub \tau' \to \sigma'$}
  \end{prooftree}

  \begin{prooftree}
    \AxiomC{$\forall j. w_j : \tau_j \sub \sigma_j$}
    \AxiomC{$\{ \overline{\ell_j} \} \subseteq \{ \overline{\ell_i} \}$}
    \RightLabel{\textsc{Extend}}
    \BinaryInfC{$\mathit{extend}(\{ w_j \}, \{ \overline{\ell_i} \} \setminus \{ \overline{\ell_j} \}) : \{\overline{\ell_i : \tau_i} \} \sub \{ \overline{\ell_j : \sigma_j} \}$}
  \end{prooftree}

  % recursive types
  \begin{center}
    \AxiomC{}
    \RightLabel{\textsc{Rec}$_1$}
    \UnaryInfC{$\unfoldR : \mu\rho.\tau \sub \tau [\mu\rho.\tau\ / \rho]$}
    \DisplayProof
    {\hskip.2in}
    \AxiomC{}
    \RightLabel{\textsc{Rec}$_2$}
    \UnaryInfC{$\unfoldL : \tau[\mu\rho.\tau / \rho] \sub \mu\rho.\tau$}
    \DisplayProof
  \end{center}
  \caption{Rules for subtyping witnesses}
  \label{fig:subtyping-witnesses}
\end{figure}

$triv$ is the trivial mapping corresponding to the $\top$ and $\bot$ rules.
$in_{1/2}$ correspond to the construction (injection) of an union type from either the first type $\tau$ or the second type $\sigma$ of the union $\tau \join \sigma$.
$proj_{1/2}$ correspond to the projection from an intersection type $\tau \meet \sigma$ to one of its constituent types $\tau$ or $\sigma$.
$\mathit{extend}$
We can interpret these morphisms as the supertype relation.
\todo{in-depth description of witness constructions (reconstruct)}

If there exists some instance declaration of type class $\Psi$ for a type $\tau$, we can directly resolve $\Psi(\tau)$.

\begin{prooftree}
  \AxiomC{$w : \instance{\Phi}{\tau}$}
  \RightLabel{\textsc{Decl}}
  \UnaryInfC{$i_\tau(w) : \Phi(\tau)$}
\end{prooftree}

Given that $\Phi(\tau) \Rightarrow \Psi(\tau)$ we can use that evidence $s$ to construct $\Phi(\tau)$ by applying it to the witness $w$ of $\Psi(\tau)$.

\begin{prooftree}
  \AxiomC{$w : \Psi(\tau)$}
  \AxiomC{$s : \Phi(\tau) \Rightarrow \Psi(\tau)$}
  \RightLabel{\textsc{SuperC}}
  \BinaryInfC{$s(w) : \Phi(\tau)$}
\end{prooftree}

We give witness derivation rules corresponding to \textsc{CoV}, \textsc{ContraV} and \textsc{InV}.
In order to construct a witness for a covariant predicate judgement, we need evidence for the judgement about a supertype and evidence that the type is in fact a supertype.

\begin{prooftree}
  \alwaysNoLine
  \AxiomC{$w : \Phi^<(\sigma)$}
  \AxiomC{$m : \tau \sub \sigma$}
  \alwaysSingleLine
  \RightLabel{\textsc{CoV}}
  \BinaryInfC{$\cov(w,m) : \Phi^<(\tau)$}
\end{prooftree}

In order to construct a witness for a contravariant predicate judgement, we need evidence for the judgement about a subtype and evidence that the type is in fact a subtype.

\begin{prooftree}
  \alwaysNoLine
  \AxiomC{$w : \Phi^>(\sigma)$}
  \AxiomC{$m : \sigma \sub \tau$}
  \alwaysSingleLine
  \RightLabel{\textsc{ContraV}}
  \BinaryInfC{$\contrav(w,m) : \Phi^>(\tau)$}
\end{prooftree}

Finally, in order to construct a witness for an invariant predicate judgement, we need evidence for the judgement about an equivalent type and evidence that the type is in fact equivalent, i.e. both a sub- and a supertype.

\begin{prooftree}
  \AxiomC{$w : \Phi(\sigma)$}
  \AxiomC{$m : \sigma \sub \tau$}
  \AxiomC{$n : \tau \sub \sigma$}
  \RightLabel{\textsc{InV}}
  \TrinaryInfC{$\inv(w,m,n) : \Phi(\tau)$}
\end{prooftree}

Just like for predicates, we can use the given rules to derive additional rules for covariant (fig. \ref{fig:derived-covariant-witnesses}) and contravariant (fig. \ref{fig:derived-contravariant-witnesses}) witnesses.

% macros
\begin{figure}[ht]
  \begin{center}
    \AxiomC{$w : \Phi^<(\top)$}
    \AxiomC{}
    \RightLabel{\textsc{Top}}
    \UnaryInfC{$\topW_\tau : \tau \sub \top$}
    \alwaysSingleLine
    \RightLabel{\textsc{CoV}}
    \BinaryInfC{$cov(w,\topW_\tau) : \Phi^<(\tau)$}
    \DisplayProof
    \deriveRule
    \AxiomC{$w : \Phi^<(\top)$}
    \alwaysSingleLine
    \RightLabel{\textsc{Top}$^<$}
    \UnaryInfC{$\cov(w,\topW_\tau)\Phi^<(\tau)$}
    \DisplayProof
  \end{center}

  \begin{center}
    \AxiomC{$w : \Phi^<(\tau)$}
    \AxiomC{}
    \RightLabel{\textsc{Bot}}
    \UnaryInfC{$\botW_\tau : \bot \sub \tau$}
    \alwaysSingleLine
    \RightLabel{\textsc{CoV}}
    \BinaryInfC{$\cov(w,\botW_\tau) : \Phi^<(\bot)$}
    \DisplayProof
    \deriveRule
    \AxiomC{$w : \Phi^<(\tau)$}
    \alwaysSingleLine
    \RightLabel{\textsc{Bot}$^<$}
    \UnaryInfC{$\cov(w,\botW_\tau) : \Phi^<(\bot)$}
    \DisplayProof
  \end{center}

  \begin{center}
    \AxiomC{$w : \Phi^<(\tau)$}
    \AxiomC{}
    \RightLabel{\textsc{Refl}}
    \UnaryInfC{$\refl_\tau : \tau \sub \tau$}
    \RightLabel{\textsc{MeetI}$_1$}
    \UnaryInfC{$\proj{1}(\refl_\tau) : \tau \meet \sigma \sub \tau$}
    \alwaysSingleLine
    \RightLabel{\textsc{CoV}}
    \BinaryInfC{$\cov(w,\proj{1}(\refl_\tau) : \Phi^<(\tau \meet \sigma)$}
    \DisplayProof
    \deriveRule
    \AxiomC{$w : \Phi^<(\tau)$}
    \alwaysSingleLine
    \RightLabel{\textsc{Meet}$_1^<$}
    \UnaryInfC{$\cov(w,\proj{1}(\refl_\tau)) : \Phi^<(\tau \meet \sigma)$}
    \DisplayProof
  \end{center}

  \begin{center}
    \AxiomC{$w : \Phi^<(\tau)$}
    \AxiomC{}
    \RightLabel{\textsc{Refl}}
    \UnaryInfC{$\refl_\tau : \tau \sub \tau$}
    \RightLabel{\textsc{MeetI}$_2$}
    \UnaryInfC{$\proj{2}(\refl_\tau) : \sigma \meet \tau \sub \tau$}
    \alwaysSingleLine
    \RightLabel{\textsc{CoV}}
    \BinaryInfC{$\cov(w,\proj{2}(\refl_\tau)) : \Phi^<(\sigma \meet \tau)$}
    \DisplayProof
    \vspace*{0.1in}
    \deriveRule
    \AxiomC{$w : \Phi^<(\tau)$}
    \alwaysSingleLine
    \RightLabel{\textsc{Meet}$_2^<$}
    \UnaryInfC{$\cov(w,\proj{2}(\refl_\tau)) : \Phi^<(\sigma \meet \tau)$}
    \DisplayProof
  \end{center}

  \begin{center}
    \AxiomC{$w : \Phi^<(\Int)$}
    \AxiomC{}
    \RightLabel{\textsc{NatPrim}}
    \UnaryInfC{$\natPrim : \Nat \sub \Int$}
    \alwaysSingleLine
    \RightLabel{\textsc{CoV}}
    \BinaryInfC{$\cov(w,\natPrim) : \Phi^<(\Nat)$}
    \DisplayProof
    \deriveRule
    \AxiomC{$w : \Phi^<(\Int)$}
    \alwaysSingleLine
    \RightLabel{\textsc{NatPrim}$^<$}
    \UnaryInfC{$\cov(w,\natPrim) : \Phi^<(\Nat)$}
    \DisplayProof
  \end{center}

  \caption{Derived rules for covariant witnesses}
  \label{fig:derived-covariant-witnesses}
\end{figure}


\begin{figure}[ht]
  \begin{center}
    \AxiomC{$w : \Phi^>(\tau)$}
    \AxiomC{}
    \RightLabel{\textsc{Top}}
    \UnaryInfC{$\topW_\tau :\tau \sub \top$}
    \alwaysSingleLine
    \RightLabel{\textsc{ContraV}}
    \BinaryInfC{$\contrav(w,\topW_\tau) : \Phi^>(\top)$}
    \DisplayProof
    \deriveRule
    \AxiomC{$w : \Phi^>(\tau)$}
    \alwaysSingleLine
    \RightLabel{\textsc{Top}$^>$}
    \UnaryInfC{$\contrav(w,\topW_\tau) : \Phi^>(\top)$}
    \DisplayProof
  \end{center}

  \begin{center}
    \AxiomC{$w : \Phi^>(\bot)$}
    \AxiomC{}
    \RightLabel{\textsc{Bot}}
    \UnaryInfC{$\botW_\tau : \bot \sub \tau$}
    \alwaysSingleLine
    \RightLabel{\textsc{ContraV}}
    \BinaryInfC{$\contrav(w,\botW_\tau) : \Phi^>(\tau)$}
    \DisplayProof
    \deriveRule
    \AxiomC{$w : \Phi^>(\bot)$}
    \alwaysSingleLine
    \RightLabel{\textsc{Bot}$^>$}
    \UnaryInfC{$\contrav(w,\botW_\tau) \Phi^>(\tau)$}
    \DisplayProof
  \end{center}

  \begin{center}
    \AxiomC{$w : \Phi^>(\tau)$}
    \AxiomC{}
    \RightLabel{\textsc{Refl}}
    \UnaryInfC{$\refl : \tau \sub \tau$}
    \RightLabel{\textsc{JoinI}$_1$}
    \UnaryInfC{$\inW{1}(\refl_\tau) : \tau \sub \tau \join \sigma$}
    \alwaysSingleLine
    \RightLabel{\textsc{ContraV}}
    \BinaryInfC{$\contrav(w,\inW{1}(\refl_\tau)) : \Phi^>(\tau \join \sigma)$}
    \DisplayProof
    \deriveRule
    \AxiomC{$w : \Phi^>(\tau)$}
    \alwaysSingleLine
    \RightLabel{\textsc{Join}$_1^>$}
    \UnaryInfC{$\contrav(w,\inW{1}(\refl_\tau)) : \Phi^>(\tau \join \sigma)$}
    \DisplayProof
  \end{center}

  \begin{center}
    \AxiomC{$w : \Phi^>(\tau)$}
    \AxiomC{}
    \RightLabel{\textsc{Refl}}
    \UnaryInfC{$\refl_\tau : \tau \sub \tau$}
    \RightLabel{\textsc{JoinI}$_2$}
    \UnaryInfC{$\inW{2}(\refl_\tau) : \tau \sub \sigma \join \tau$}
    \alwaysSingleLine
    \RightLabel{\textsc{ContraV}}
    \BinaryInfC{$\contrav(w,\inW{2}(\refl_\tau)) : \Phi^>(\sigma \join \tau)$}
    \DisplayProof
    \deriveRule
    \AxiomC{$w : \Phi^>(\tau)$}
    \alwaysSingleLine
    \RightLabel{\textsc{Join}$_2^>$}
    \UnaryInfC{$\contrav(w,\inW{2}(\refl_\tau)) : \Phi^>(\sigma \join \tau)$}
    \DisplayProof
  \end{center}

  \begin{center}
    \AxiomC{$w : \Phi^>(\Nat)$}
    \AxiomC{}
    \RightLabel{\textsc{NatPrim}}
    \UnaryInfC{$\natPrim : \Nat \sub \Int$}
    \alwaysSingleLine
    \RightLabel{\textsc{ContraV}}
    \BinaryInfC{$\contrav(w,\natPrim) : \Phi^>(\Int)$}
    \DisplayProof
    \deriveRule
    \AxiomC{$w : \Phi^>(\Nat)$}
    \alwaysSingleLine
    \RightLabel{\textsc{NatPrim}$^>$}
    \UnaryInfC{$\contrav(w,\natPrim) : \Phi^>(\Int)$}
    \DisplayProof
  \end{center}

  \caption{Derived rules for contravariant witnesses}
  \label{fig:derived-contravariant-witnesses}
\end{figure}

% We can obtain witnesses from and to the initial and terminal types $\bot$ and $\top$ with trivial morphism corresponding to the \textsc{Bot} and \textsc{Top} subtyping rules.

% \begin{center}
%   \alwaysNoLine
%   \AxiomC{$w : \Phi^<(\top)$}
%   \alwaysSingleLine
%   \RightLabel{\textsc{Top}$^<$}
%   \UnaryInfC{$triv(w) : \Phi^<(\tau)$}
%   \DisplayProof
%   {\hskip.2in}
%   \alwaysNoLine
%   \AxiomC{$w : \Phi^<(\tau)$}
%   \alwaysSingleLine
%   \RightLabel{\textsc{Bot}$^<$}
%   \UnaryInfC{$triv(w) : \Phi^<(\bot)$}
%   \DisplayProof
% \end{center}

% \begin{center}
%   \alwaysNoLine
%   \AxiomC{$w : \Phi^>(\tau)$}
%   \alwaysSingleLine
%   \RightLabel{\textsc{Top}$^>$}
%   \UnaryInfC{$triv(w) : \Phi^>(\top)$}
%   \DisplayProof
%   {\hskip.2in}
%   \alwaysNoLine
%   \AxiomC{$w : \Phi^>(\bot)$}
%   \alwaysSingleLine
%   \RightLabel{\textsc{Bot}$^>$}
%   \UnaryInfC{$triv(w) : \Phi^>(\tau)$}
%   \DisplayProof
% \end{center}

% Interpreting $in_{1/2}$ and $proj_{1/2}$ as morphisms from a type to one of its supertypes the rules corresponding to the covariant \textsc{Join}$^<$ and \textsc{Meet}$^<$ rules are obvious.

% \begin{center}
%   \AxiomC{$in_1(w) : \Phi^<(\tau \join \sigma)$}
%   \RightLabel{\textsc{Join}$_1^<$}
%   \UnaryInfC{$w : \Phi^<(\tau)$}
%   \DisplayProof
%   {\hskip.2in}
%   \AxiomC{$in_2(w) : \Phi^<(\tau \join \sigma)$}
%   \RightLabel{\textsc{Join}$_2^<$}
%   \UnaryInfC{$w : \Phi^<(\sigma)$}
%   \DisplayProof
% \end{center}

% \begin{center}
%   \AxiomC{$proj_1(w) : \Phi^<(\tau)$}
%   \RightLabel{\textsc{Meet}$_1^<$}
%   \UnaryInfC{$w : \Phi^<(\tau \meet \sigma)$}
%   \DisplayProof
%   {\hskip.2in}
%   \AxiomC{$proj_2(w) : \Phi^<(\sigma)$}
%   \RightLabel{\textsc{Meet}$_2^<$}
%   \UnaryInfC{$w : \Phi^<(\tau \meet \sigma)$}
%   \DisplayProof
% \end{center}

% Analagously, with the interpretation of $in_{1/2}$ and $proj_{1/2}$  the rules corresponding to the contravariant \textsc{Join}$^>$ and \textsc{Meet}$^>$ rules are again obvious.

% \begin{center}
%   \AxiomC{$w : \Phi^>(\tau \meet \sigma)$}
%   \RightLabel{\textsc{Meet}$_1^>$}
%   \UnaryInfC{$proj_1(w) : \Phi^>(\tau)$}
%   \DisplayProof
%   {\hskip.2in}
%   \AxiomC{$w : \Phi^>(\tau \meet \sigma)$}
%   \RightLabel{\textsc{Meet}$_2^>$}
%   \UnaryInfC{$proj_2(w) : \Phi^<(\sigma)$}
%   \DisplayProof
% \end{center}

% \begin{center}
%   \AxiomC{$w : \Phi^>(\tau)$}
%   \RightLabel{\textsc{Join}$_1^>$}
%   \UnaryInfC{$in_1(w) : \Phi^>(\tau \join \sigma)$}
%   \DisplayProof
%   {\hskip.2in}
%   \AxiomC{$w : \Phi^>(\sigma)$}
%   \RightLabel{\textsc{Join}$_2^>$}
%   \UnaryInfC{$in_2(w) : \Phi^>(\tau \join \sigma)$}
%   \DisplayProof
% \end{center}

\subsection{Examples}

We present witness derivations for the examples in the previous section.
The context is replaced with an instance declaration which forms the leaf in the derivation. (fig. \ref{fig:witness-example-defaultable} \& fig. \ref{fig:witness-example-showable})

\begin{figure}[ht]
  \begin{prooftree}
    \AxiomC{$w : \mathbf{instance} \; \Showable(\Int)$}
    \RightLabel{\textsc{Decl}}
    \UnaryInfC{$i_\Int(w) : \Showable(\Int)$}
    \AxiomC{}
    \RightLabel{\textsc{NatPrim}$^<$}
    \UnaryInfC{$\mathit{natPrim} : \Nat \sub \Int$}
    \RightLabel{\textsc{Meet}$^<_2$}
    \UnaryInfC{$\mathit{proj}_2(\mathit{natPrim}) : \Singleton{1} \meet \Nat \sub \Int$}
    \RightLabel{\textsc{CoV}}
    \BinaryInfC{$cov(i_\Int(w), \mathit{proj}_2(\mathit{natPrim})) : \Showable(\Singleton{1} \meet \Nat)$}
  \end{prooftree}
  \caption{Witness derivation for $cov(i_\Int(w), \mathit{proj}_2(\mathit{natPrim})) : \Showable(\Unit \meet \Nat)$}
  \label{fig:witness-example-showable}
\end{figure}

\begin{figure}[ht]
  \begin{prooftree}
    \AxiomC{$w : \mathbf{instance} \; \Defaultable(\Nat)$}
    \RightLabel{\textsc{Decl}}
    \UnaryInfC{$i_\Nat(w) : \Defaultable(\Nat)$}
    \AxiomC{}
    \RightLabel{\textsc{NatPrim}$^<$}
    \UnaryInfC{$\mathit{natPrim} : \Nat \sub \Int$}
    \RightLabel{\textsc{Meet}$^<_2$}
    \UnaryInfC{$\mathit{in}_1(\mathit{natPrim}) : \Nat \sub \Bool \join \Int$}
    \RightLabel{\textsc{CoV}}
    \BinaryInfC{$contrav(i_\Nat(w), \mathit{in}_1(\mathit{natPrim})) : \Defaultable(\Int \join \Bool)$}
  \end{prooftree}
  \caption{Witness derivation for $contrav(i_\Nat(w), \mathit{in}_1(\mathit{natPrim})) : \Defaultable(\Int \join \Bool)$}
  \label{fig:witness-example-defaultable}
\end{figure}

\section{Inclusive Subtyping}

We assume a naive set-theoretic definition of subtyping analagous to the one given by Castagna and Xu \cite{castagna}:

\begin{definition} Subtyping\\
  $\tau \sub \sigma \Leftrightarrow [\tau] \subseteq [\sigma]$ where $[\tau]$ is the set  of all witnesses of $\tau$.
\end{definition}

This notion of subtyping trivially satsifies the Liskov substitution principle.
Because with $\tau \sub \sigma$ for every $e : \tau$ we also have $e : \sigma$, the coercion function is the identity.
Thus all properties are preserved for terms over the subtyping relation.

With the types at hand, this is easy to follow.
We can trivially translate the types of $\Nat$ and $\Int$ into corresponding sets.
The singleton types can be interpreted as $\Singleton{0} \rightsquigarrow \{0\}$, $\Singleton{1} \rightsquigarrow \{1\}$, \dots
Adding lattice types $\bot \rightsquigarrow \emptyset$ and $\top \rightsquigarrow \{ S | \forall M. M \subseteq S \}$,  we also have correspondents to union and intersection types with the union and intersection of sets.

Given inclusive subtyping, we may be motivated to introduce some additional rules.
E.g. given $\Showable(\Bool)$ and $\Showable(\Nat)$, it may seem tempting to derive $\Showable(\Bool \join \Nat)$,
so that the term $\lambda b. \showTerm(\ifthenelseTerm b \; b \; 42)$ is typeable.
Introducing union types can only be done with some restrictions: \todo{rework}

\begin{prooftree}
  \AxiomC{$\ctx \Phi^<(\rho)$}
  \AxiomC{$\tau \sub \rho$}
  \AxiomC{$\sigma \sub \rho$}
  \RightLabel{\textsc{JoinI}}
  \BinaryInfC{$\tau \join \sigma \sub \rho$}
  \alwaysSingleLine
  \RightLabel{\textsc{CoV}}
  \BinaryInfC{$\ctx \Phi^<(\tau \join \sigma)$}
\end{prooftree}

The \textsc{Join} rule can not be derived with the subtyping rules because $\tau \join \sigma$ is neither a subtype of $\tau$ nor of $\sigma$.
In fact, only the opposite holds.
However, there is a motivation for it:
% With the definition of covariant predicates the premises express that for all terms of type $\tau$ and $\sigma$ the characteristic property holds.
Since every term of type $\tau \join \sigma$ is a term of type $\tau$ or $\sigma$, $\Phi(\tau \join \sigma)$ holds.

\begin{prooftree}
  \alwaysNoLine
  \AxiomC{$\ctx \Phi^<(\sigma)$}
  \AxiomC{$\ctx \Phi^<(\tau)$}
  \alwaysSingleLine
  \RightLabel{\textsc{Join}$^<$}
  \BinaryInfC{$\ctx \Phi^<(\tau\join\sigma)$}
\end{prooftree}

Dually, introducing a rule for contravariant predicates on intersection types can also only be done with some restrictions:

\begin{prooftree}
  \AxiomC{$\ctx \Phi^>(\tau)$}
  \AxiomC{$\tau \sub \sigma$}
  \AxiomC{$\tau \sub \rho$}
  \RightLabel{\textsc{MeetI}}
  \BinaryInfC{$\tau \sub \sigma \meet \rho$}
  \alwaysSingleLine
  \RightLabel{\textsc{ContraV}}
  \BinaryInfC{$\ctx \Phi^>(\sigma \meet \rho)$}
\end{prooftree}

However, the \textsc{Meet} rule can not be derived with the subtyping rules because $\tau \meet \sigma$ is neither a supertype of $\tau$ nor of $\sigma$.
% With the definition of contravariant predicates the premises express that for some witnesses of $\tau$ and $\sigma$ the characteristic property holds.
But even though this rule is dual to the \textsc{Join}-rule above, we cannot motivate it.
If some witness of $\tau \meet \sigma$ is a witness of both $\tau$ and $\sigma$, $\Phi(\tau \meet \sigma)$ holds.
However, there is no guarantee that a term of type $\tau$ or of type $\sigma$ is also of type $\tau \meet \sigma$, e.g. if $\tau \meet \sigma = \bot$.
% this rule is bogus:
% if \tau and \sigma are disjoint there is no possible witness in \tau \meet \sigma...

\begin{prooftree}
  \alwaysNoLine
  \AxiomC{$\ctx \Phi^>(\sigma)$}
  \AxiomC{$\ctx \Phi^>(\tau)$}
  \alwaysSingleLine
  \RightLabel{\textsc{Meet}$^>$}
  \BinaryInfC{$\ctx \Phi^>(\tau\meet\sigma)$}
\end{prooftree}


In the end however, we can only resolve these constraints if the predicate in question is monotonous on the witnesses of a type.
Predicates that relate witnesses with each other such as $\Ordable$ are not trivially satisfied for the union of two types if they hold for both respectively.
Consider an ordering of natural numbers $o_\Nat : \Ordable (\Nat)$ and an ordering of booleans $o_\Bool : \Ordable (\Bool)$.
It is not ambiguous how to define the ordering $o : \Ordable (\Nat \join \Bool)$.
$\mathbf{true} \leq 1$ has to be defined in some way, but since it is ambiguous we cannot define it without violating type class coherence.


The rules \textsc{Join}$^<$ and \textsc{Meet}$^>$ as mentioned before cannot be derived from the subtyping rules alone.
It may seem intuitive that given $\Showable(\tau)$ and $\Showable(\sigma)$ we also have $\Showable(\tau \join \sigma)$.
Dually, we could also be able to resolve $\Readable(\tau \meet \sigma)$ from $\Readable(\tau)$ and $\Readable(\sigma)$.

However these rules cannot be implemented generally.
Consider type classes with methods in which the bound type variable occurs more than once (unlike in $\Showable$ and $\Readable$).
As an example where this rule cannot be implemented, let us look at the $Eq$ type class:

\begin{gather}
\nonumber {\bf class} \; \Eq(a) \; where\\
\nonumber  eq : a \to a \to \Bool
\end{gather}

Given instances $\Eq(\Nat)$ and $\Eq(\Bool)$, we may expect to have $\Eq(\Nat \join \Bool)$ but e.g. the term $5 == True$ cannot be trivially implemented based on known implementations for $==$.
Based on the assumptions we already know how to compare terms of type $\Nat$ with each other and terms of type $\Bool$ with each other,
however we have no information available on how to compare a term of type $\Bool$ with a term of type $\Nat$.
In this example, it would be easy to provide $false$ as a default value but constructing default values is going to be complicated for more sophisticated type classes.
In fact the $\Ordable$ type class already would be problematic using default values.

Therefore, these non-derivable rules cannot be used for type class resolution.

% not a good counterexample: here we should just choose the "smaller" instance
% even though this is undecidable in other cases, see above

% More surprisingly perhaps, even finding an implementation for $\Readable(\tau \meet \sigma)$ can lead to problems.
% Consider the following instances for $\Readable(\Nat)$ and $\Readable(\Int)$:


% \begin{figure}[ht]
%   \centering
%   \begin{subfigure}{0.4\textwidth}
%   \begin{flalign*}
%   & \instance{\Readable}{\Nat} : \\
%   & \; \; \mathit{read} : \String \to \Nat \\
%   & \; \; \mathit{read} \; str := \; 0
%   \end{flalign*}
%   \end{subfigure}
%   \hfill
%   \begin{subfigure}{0.4\textwidth}
%   \begin{flalign*}
%   & \instance{\Readable}{\Int} : \\
%   & \; \; \mathit{read} : \String \to \Int \\
%   & \; \; \mathit{read} \; str := \; 1
%   \end{flalign*}
%   \end{subfigure}
% \label{fig:read-instances}
% \caption{Instances for $\Readable(\Nat)$ and $\Readable(\Int)$}
% \end{figure}

% The intersection type $\Nat \meet \Int$ is equivalent to $\Nat$.
% However, based on these instance declarations it is ambiguous whether the derived instance for $\Readable(\Nat \meet \Int)$ will be the same as the declared instance for $\Readable{\Nat}$.


% explain problems for intersection in contravariant type classes


% There is a problem when we want to implement the union type.

% Consider again the \texttt{Show} typeclass. It is intuitive to see how we can construct the \texttt{show} method for the union of two types, given that it is defined for both respecetively.
% However, looking at the \texttt{Eq} typeclass, we can not generally deduce an instance of the join of two types.
% If we solely know how to compare terms of type $\tau$ with each other and how to compare terms of type $\sigma$ with each other,
% we do not know how to compare a term of type $\tau$ with a term of type $\sigma$, even though the derived instance tells we should be able to do so.

% \begin{gather}
%   \nonumber show_{a\join b} \; x := {\bf if} \; typeOf \; x == a \; {\bf then} \; show_a \; x \; {\bf else} \; show_b \; x
% \end{gather}

% We might be able to just return \texttt{False} as a default value in such cases but even default values can be ambiguous.
% Consider now the \texttt{Ord} type class. Given \texttt{Ord a} and \texttt{Ord b} we may say that in \texttt{Ord a $\join$ b} every $a$ is ordered before $b$.
% But given the commutativity of $\join$, this would violate type class coherence because $a \join b = b \join a$ but \texttt{Ord a $\join$ b} $\neq$ \texttt{Ord b $\join$ a}.


