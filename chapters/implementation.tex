\chapter{Implementation}
\label{ch:implementation}

\section{Example}

We introduce the type class $\mathit{Summable}$ of types which can be summed up or folded into a natural number.

\begin{flalign*}
& \mathbf{class} \; \mathit{Summable}(+a)\{ \\
& \;\;\; \mathbf{sum} : a  \to \Nat \\
& \}
\end{flalign*}

We can implement this type class for pairs of natural  numbers by simply adding up the components.

\begin{flalign*}
& \mathbf{instance} \; \mathit{Summable} \; \Nat \{ \\
& \;\;\; \mathbf{sum} := \mathbf{id} \\
& \}
\end{flalign*}

Given a definition for non-empty lists, we can also use an instance recursively to sum up its elements:


\begin{flalign*}
& \mathbf{data} \; \mathit{NonEmpty} \{ \\
& \;\;\; \mathit{Singleton}(\Nat) \\
& \;\;\; \mathit{Cons}(\Nat, \mathit{NonEmpty})\\
& \}
\end{flalign*}

\begin{flalign*}
& \mathbf{instance} \; \mathit{Summable} \; \mathit{NonEmpty} \{ \\
& \;\;\; \mathbf{sum} := \lambda l. \mathbf{case} \; l \; of \\
& \;\;\;\;\; \mathit{Singleton}(n) \Rightarrow n \\
& \;\;\;\;\; \mathit{Cons}(n, ns) \Rightarrow n + (\mathbf{sum}[\mathit{NonEmpty}] \; ns) \\
& \}
\end{flalign*}

Similarily, we can define a $\mathit{Summable}$ instance for leaf-oriented trees.

\begin{flalign*}
& \mathbf{data} \; \mathit{NatTree} \{ \\
& \;\;\; \mathit{Leaf}(\Nat) \\
& \;\;\; \mathit{Branch}(\mathit{NatTree}, \mathit{NatTree})\\
& \}
\end{flalign*}

\begin{flalign*}
& \mathbf{instance} \; \mathit{Summable} \; \mathit{NatTree} \{ \\
& \;\;\; \mathbf{sum} := \lambda t. \mathbf{case} \; t \; of \\
& \;\;\;\;\; \mathit{Leaf}(n) \Rightarrow n \\
& \;\;\;\;\; \mathit{Branch}(l, r) \Rightarrow (\mathbf{sum}[\mathit{NatTree}] \; l) + (\mathbf{sum}[\mathit{NatTree}] \; r) \\
& \}
\end{flalign*}

\section{Duo}

\emph{Duo} is a research language developed at the University of T\"ubingen. \cite{duo}
It is a statically typed functional language with an emphasis on duality.
Unlike most known functional languages its type system is based on sequent calculus style deduction rather than natural deduction.
Most notably, computation happens as a "cut" between producer and consumer terms using the \lstinline{>>} operator.

E.g. in the program in listing \ref{code:duo-example} the producer \lstinline{True} is matched against a consumer, i.e. a pattern-match on booleans, which simply exits the program.

\begin{lstlisting}[style=duostyle, label=code:duo-example, captionpos=b, caption={Example duo code}]
def cmd foo := True >> case {
    True => #ExitSuccess;
    False => #ExitFailure
};
\end{lstlisting}

The nature of \emph{duo} has some special implications for the implementation of type classes as well:
In class declarations, we have a kind signature for the type variable bound by the declaration.
Here, we also define the variance of the variable.
We implement methods as commands.

\begin{lstlisting}[style=duostyle, label=code:duo-class-decl, captionpos=b, caption={Type class declaration  in \emph{duo}}]

class Summable(+a : CBV){
    Sum(a, return Nat)
};

\end{lstlisting}

An instance is named, which makes it easier to reference internally.
In the instance we have to implement each method declared in the class declaration as a command.

\begin{lstlisting}[style=duostyle, label=code:duo-nat-list, captionpos=b, caption={Instance declaration for natural numbers in \emph{duo}}]
instance natSummable : Summable Nat {
    Sum(n, k) => n >> k
};
\end{lstlisting}

\emph{Duo} supports the usual algebraic data types. Non-empty lists of natural numbers can be defined like this:

\begin{lstlisting}[style=duostyle, label=code:duo-nat-list, captionpos=b, caption={Data and instance declaration for non-empty lists of in \emph{duo}}]

data NatList {
    Singleton(Nat),
    Cons(Nat, NatList)
};

instance natListSummable : Summable NatList {
    Sum(l, k) => case l of {
        Singleton(n) => n >> k,
        Cons(n, ns) => Sum(ns, mu x. add x n >> k)
    }
};

\end{lstlisting}

We can also add more instances. For example, for non-empty leaf-oriented binary trees.

\begin{lstlisting}[style=duostyle, label=code:duo-tree-instance, captionpos=b, caption={Type class example  in \emph{duo}}]

data NatTree {
    Leaf(Nat),
    Branch(NatTree, NatTree)
};

instance natTreeSummable : Summable NatTree {
    Sum(t, k) => case t of {
        Leaf(n) => n >> k,
        Branch(l, r) => add (mu k1. Sum(l, k1))
                            (mu k2. Sum(r, k2)) >> k
    }
};

\end{lstlisting}

% Outline the duo language
Several checks have been implemented to ensure type class coherence in \emph{duo}:
We disallow any orphan instances by requiring an instance declaration to be placed in the same module as the data or class declaration.
When declaring an instance, we check for all instances of the same type class in scope whether the overlap with the type the instance is being declared for is empty.


\section{Refinement Types}
\label{sec:refinement-types}

Refinement types can be viewed as a specialisation of nominal types.
Using them, we can impose additional constraints on types and therefore obtain a more precise typing judgement. \cite{springer} %FIXME wrong citation
In \emph{duo} refinement types are declared very similarily as nominal types:

\begin{lstlisting}[style=duostyle, label=code:duo-refinement-declaration, captionpos=b, caption={Refinement type of peano numbers in \emph{duo}}]

refinement data Nat {
    Z,
    S(Nat)
};

\end{lstlisting}

The type inference algorithm in duo is expanded to refinement types and therefore able to infer very precise types for terms.
As we can see in listing \ref{code:duo-refinement-example} the type for the simple term \lstinline{Z} reflects that it can only be constructed by \lstinline{Z}, therefore we know from looking at the type alone, that the only value of this term can be zero.
We also need recursive types to allow recursive refinement types as seen in \lstinline{double}.
Here we can see that any natural number is permitted as input but only numbers constructed by an even number of \lstinline{S} constructors will be in the output.
In this case refinement types can assure us that this function will only produce even numbers.

\begin{lstlisting}[style=duostyle, label=code:duo-refinement-example, captionpos=b, caption={Type inference for refinement types in \emph{duo}}]

def rec prd zero : < Nat | Z > := Z;

def rec prd double : (rec a.(<Nat | Z, S(a)>))
                  -> (rec a.(<Nat | Z, S(< Nat | S(a)>)>))
    := \n => case n of {
      Z => Z,
      S(n) => S(S(double n))
    };
    
\end{lstlisting}

% TODO: bring type classes and refinement types together