\chapter{Implementation}
\label{ch:implementation}

\section{Example}

We introduce the type class $\mathit{Summable}$ of types which can be summed up or folded into a natural number.

\begin{flalign*}
& \mathbf{class} \; \mathit{Summable}(+a)\{ \\
& \;\;\; \mathbf{sum} : a  \to \Nat \\
& \}
\end{flalign*}

We can implement this type class for pairs of natural  numbers by simply adding up the components.

\begin{flalign*}
& \mathbf{instance} \; \mathit{Summable} \; \mathit{Pair}(\Nat,\Nat) \{ \\
& \;\;\; \mathbf{sum} := \lambda p. \mathbf{case} \; p \; of \\
& \;\;\;\;\; (n,m) \Rightarrow n+m \\
& \}
\end{flalign*}

Given a definition for non-empty lists, we can also use an instance recursively to sum up its elements:


\begin{flalign*}
& \mathbf{data} \; \mathit{NonEmpty} \{ \\
& \;\;\; \mathit{Singleton}(\Nat) \\
& \;\;\; \mathit{Cons}(\Nat, \mathit{NonEmpty})\\
& \}
\end{flalign*}

\begin{flalign*}
& \mathbf{instance} \; \mathit{Summable} \; \mathit{NonEmpty} \{ \\
& \;\;\; \mathbf{sum} := \lambda l. \mathbf{case} \; l \; of \\
& \;\;\;\;\; \mathit{Singleton}(n) \Rightarrow n \\
& \;\;\;\;\; \mathit{Cons}(n, ns) \Rightarrow n + (\mathbf{sum}[\mathit{NonEmpty}] \; ns) \\
& \}
\end{flalign*}

Similarily, we can define a $\mathit{Summable}$ instance for leaf-oriented trees.

\begin{flalign*}
& \mathbf{data} \; \mathit{NatTree} \{ \\
& \;\;\; \mathit{Leaf}(\Nat) \\
& \;\;\; \mathit{Branch}(\mathit{NatTree}, \mathit{NatTree})\\
& \}
\end{flalign*}

\begin{flalign*}
& \mathbf{instance} \; \mathit{Summable} \; \mathit{NatTree} \{ \\
& \;\;\; \mathbf{sum} := \lambda t. \mathbf{case} \; t \; of \\
& \;\;\;\;\; \mathit{Leaf}(n) \Rightarrow n \\
& \;\;\;\;\; \mathit{Branch}(l, r) \Rightarrow (\mathbf{sum}[\mathit{NatTree}] \; l) + (\mathbf{sum}[\mathit{NatTree}] \; r) \\
& \}
\end{flalign*}

\section{Duo}

\emph{Duo} is a research language developed at the University of T\"ubingen. \cite{duo}
It is a statically typed functional language with an emphasis on duality.
Unlike most known functional languages its type system is based on sequent calculus style deduction rather than natural deduction.
Most notably, computation happens as a "cut" using the \lstinline{>>} operator.

\begin{lstlisting}[style=duostyle, label=code:duo-example, captionpos=b, caption={Example duo code}]
def cmd foo := True >> case {
    True => #ExitSuccess;
    False => #ExitFailure
};
\end{lstlisting}

The nature of \emph{duo} has some special implications for the implementation of type classes as well:
In class declarations, we have a kind signature for the type variable bound by the declaration.
Here, we also define the variance of the variable.
We implement methods as commands.

\begin{lstlisting}[style=duostyle, label=code:duo-class-decl, captionpos=b, caption={Type class declaration  in \emph{duo}}]

class Summable(+a : CBV){
    Sum(a, return Nat)
};

\end{lstlisting}

\emph{Duo} supports the usual algebraic data types. Non-empty lists of natural numbers can be defined like this:

\begin{lstlisting}[style=duostyle, label=code:duo-nat-list, captionpos=b, caption={Data declaration for non-empty lists of natural numbers in \emph{duo}}]

data NatList {
    Singleton(Nat),
    Cons(Nat, NatList)
};

\end{lstlisting}

An instance is named, which makes it easier to reference internally.
In the instance we have to implement each method declared in the class declaration as a command.

\begin{lstlisting}[style=duostyle, label=code:duo-list-instance, captionpos=b, caption={Instance declaration for non-empty lists in \emph{duo}}]

instance natListSummable : Summable NatList {
    Sum(l, k) => case l of {
        Singleton(n) => n >> k,
        Cons(n, ns) => Sum(ns, mu x. add x n >> k)
    }
};

\end{lstlisting}

We can also add more instances. For example, for non-empty leaf-oriented binary trees.

\begin{lstlisting}[style=duostyle, label=code:duo-tree-instance, captionpos=b, caption={Type class example  in \emph{duo}}]

data NatTree {
    Leaf(Nat),
    Branch(NatTree, NatTree)
};

instance natTreeSummable : Summable NatTree {
    Sum(t, k) => case t of {
        Leaf(n) => n >> k,
        Branch(l, r) => add (mu k1. Sum(l, k1))
                            (mu k2. Sum(r, k2)) >> k
    }
};

\end{lstlisting}

% Outline the duo language
Several checks have been implemented to ensure type class coherence in \emph{duo}:
We disallow any orphan instances by requiring an instance declaration to be placed in the same module as the data or class declaration.
When declaring an instance, we check for all instances of the same type class in scope whether the overlap with the type the instance is being declared for is empty.


\section{Pipeline}

% explain, how to get from the surface syntax to a typechecked runnable program
% parsing, resolution, desugaring, constraint generation, solving, instance resolution

\section{Remarks}

% Outline the interaction between type classes and miscelleanous language features
% e.g. refinement types
